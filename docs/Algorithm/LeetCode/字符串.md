# 字符串

这一部分主要集中了字符串相关的题目，例如回文字符串、翻转字符串，还有 C 标准库的相关字符串函数实现。

## 回文字符串

---

### 9. 回文数

**题目：**

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**解答：**

* 将整数转为字符串。
* 将整数倒序（整数可能会溢出）。
* 将整数截取一半进行比较。

这里我演示第三种方法的代码，将整数截取一半然后进行比较。

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) return false;
        
        // 获取整数的位数
        int temp = 1;
        while (x / temp >= 10) {
            temp *= 10;
        }
        
        // 头尾进行比较
        while (x != 0) {
            int i = x % 10;
            int j = x / temp;
            if (i != j) {
                return false;
            } else {
                // 去头去尾，所以temp要一次性减两位
                x = (x % temp) / 10;
                temp /= 100;
            }
        }
        
        return true;
    }
};
```

## 字符串大小写转换

---

### 709. 转换成小写字母

**题目：**

实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。

**解答：**

```cpp
class Solution {
public:
    string toLowerCase(string str) {
        for (int i = 0; i < str.length(); i++) {
            if (str[i] >= 'A' && str[i] <= 'Z') {
                str[i] += 'a' - 'A';
            }
        }
            
        return str;
    }
};
```

## 字符翻译

---

### 804. 唯一摩尔斯密码词

**题目：**

给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，"cab" 可以写成 "-.-.-....-"，(即 "-.-." + "-..." + ".-"字符串的结合)。我们将这样一个连接过程称作单词翻译。

返回我们可以获得所有词不同单词翻译的数量。

**解答：**

这一题用到了`set`结构，该结构的特点就是数据不会重复，且插入与排序的效率很不错，有兴趣的可以去了解一下。

```cpp
class Solution {
public:
    int uniqueMorseRepresentations(vector<string>& words) {
        vector<string> password = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        
        unordered_set<string> set;
        
        for (auto e : words) {
            string temp = "";
            for (auto j : e) {
                temp += password[(int)j - 'a'];
            }
            set.insert(temp);
        }
        
        return set.size();
    }
};
```

## 字符串反转

---

### 344. 反转字符串

**题目：**

请编写一个函数，其功能是将输入的字符串反转过来。

**解答：**

```cpp
class Solution {
public:
    string reverseString(string s) {
        string::size_type mid = (s.end() - s.begin()) / 2;

        for (auto iterBegin = s.begin(); iterBegin != s.begin() + mid; iterBegin++)
        {
            swap(*iterBegin, *(s.begin() + (s.end() - iterBegin - 1)));
        }

        return s;
    }
};
```

### 557. 反转字符串中的单词 III

**题目：**

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

**解答：**

反转每一个单词即可，遇到空格就反转之前的单词。别忘了反转最后一个单词。

```cpp
class Solution {
public:
    string reverseWords(string s) {
        int t = 0;

        for(int i = 0; i <= s.length(); i++){
            if(s[i] == ' '){
                reverse(s.begin() + t, s.begin() + i);
                t = i + 1;
            }
        }

        reverse(s.begin() + t, s.end());

        return s;
    }
};
```

## 字符串的组合

---

### 22. 括号生成

**题目**

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

**解答**

在解答这个问题，首先要搞清楚什么是有效的括号组合。简单点来说，对于当前的字符串，左括号数是肯定要大于等于右括号数的，否则这个字符串就是非法的。反过来说，如果剩下的左括号比右括号多，那么就得减掉当前分支。

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        gener("", res, n, n);
        return res;
    }

    void gener(string s, vector<string>& res, int left, int right){
        // 剩余的左括号比右括号多，字符串非法，剪枝
        if (left > right) { return; }

        if(left == 0 && right == 0) {
            res.push_back(s);
            return;
        }

        // 不停地插入左括号
        if(left > 0) {
            gener(s + "(", res, left - 1, right);
        }

        // 每当剩余的左括号比右括号少时，向字符串插入一个右括号
        if(left < right) {
            gener(s + ")", res, left, right - 1);
        }
    }
};
```

### 921. 使括号有效的最少添加

**题目**

给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。

**解答**

这题其实就是栈计算器的思想，当遇到左括号时入栈，遇到右括号时栈中弹出一个左括号并且总长度减二。由于左右括号的数目是不匹配的，因此取出左括号时需要加个非空判断。最后，字符串剩下的长度就是需要额外添加的括号数。

```cpp
class Solution {
public:
    int minAddToMakeValid(string S) {
        int len = S.length();
        int leftCount = 0;
        
        for (auto e : S) {
            if (e == '(') {
                // 这里我直接记录了左括号数，没有使用栈
                leftCount++;
            }
            
            if (e == ')' && leftCount > 0) {
                leftCount--;
                len -= 2;
            }
        }
        
        return len;
    }
};
```

## 字符串匹配

---

### 890. 查找和替换模式

**题目**

你有一个单词列表 words 和一个模式  pattern，你想知道 words 中的哪些单词与模式匹配。

如果存在字母的排列 p，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。

（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）

返回 words 中与给定模式匹配的单词列表。

你可以按任何顺序返回答案。

**解答**

其实不要想复杂了，既然题目说了每一个字母只映射到另一个字母，不存在两个字母映射同一个字母的情况，那么就说明这一对字母是互相对应的。我们只需准备两个数组，然后在对应的位置存储该字母的映射即可。比如现在是 a 映射到 b，那么如果出现 a 映射到 b，或者 c 映射到 b，那么显然就是错误的。

代码我写的可能不是很详细，各位只需要明白一点，a 与 b 的映射关系是双向的，然后基于这一点进行检查即可。

```cpp
class Solution {
public:
    vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
        for (auto e : words) {
            char *chArray1 = new char[26]();        // chArray1用于标记pattern
            char *chArray2 = new char[26]();        // chArray2用于标记words
            bool isTure = true;
            
            for (int i = 0; i < e.length(); i++) {
                int index1 = pattern[i] - 'a';
                int index2 = e[i] - 'a';
                
                // 当pattern[i]未标记时，检查对应的e[i]是否也未标记。如果都未标记，那么这一对字母就是映射。
                // 如果e[i]已经被标记了，那么就查看e[i]存储的映射是否为pattern[i]，不是的话证明字符串不匹配
                if (chArray1[index1] < 'a') {
                    if (chArray2[index2] < 'a') {
                        chArray1[index1] = e[i];
                        chArray2[index2] = pattern[i];
                        
                    } else if (chArray2[index2] >= 'a' && chArray2[index2] != pattern[i]) {
                        isTure = false;
                        break;
                    }
                    
                } else if (chArray1[index1] >= 'a' && chArray1[index1] != e[i]) {
                    isTure = false;
                    break;
                }
            }
            
            if (isTure) { answer.push_back(e); }
        }
        
        return answer;
    }
    
private:
    vector<string> answer;
};
```