# 字符串

这一部分主要集中了字符串相关的题目，例如回文字符串、翻转字符串，还有 C 标准库的相关字符串函数实现。

## 回文字符串

---

### 9. 回文数

**题目：**

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**解答：**

* 将整数转为字符串。
* 将整数倒序（整数可能会溢出）。
* 将整数截取一半进行比较。

这里我演示第三种方法的代码，将整数截取一半然后进行比较。

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) return false;
        
        // 获取x的位数，用于去掉最高位
        int temp = 1;
        while (x / temp >= 10) {
            temp *= 10;
        }
        
        // 将x的头尾进行比较
        while (x != 0) {
            if (x % 10 != x / temp) {
                return false;
            } else {
                // 去头去尾，所以temp要一次性减两位
                x = (x % temp) / 10;
                temp /= 100;
            }
        }
        
        return true;
    }
};
```

### 5. 最长回文子串

**题目：**

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

**解答：**

这道题目有多种解法，首先最能够想到的是暴力检索，将以每个字符串为首的子串都检索一遍，然后找出最长的回文子串。显然，这种做法是不可取的，我们得还一种思路。

另一种可能想得到的解法是把字符串 s1 倒过来变成 s2，然后找出两个字符串 s1、s2 中的最长公共子串。不过这种做法有个小问题，就是得到的最长公共子串不一定是回文字符串，比如 `abacdfgdcaba`，得到的最长公共子串是 `abacd`。因此，当我们每次得到最长公共子串的时候，必须判断 s2 中子串的原始索引是否等于 s1 的子串索引，如果相等那么就更新最长公共子串（这一部分不懂可以去看最长公共子串）。

当然，相对比较好的做法是使用动态规划来做。动态规划较为显著的特征是求某一问题的值可以通过较小问题的答案来求得，一般来说需要整理出一个状态转移方程。对于最长回文子串来说，假设 `L[i,j]=1` 代表从第 `i` 个字符到第 `j` 个字符是回文子串，那么必定存在 `L[i+1,j-1]=1`。明白了这一点，剩下的就好做了。

在最开始时，所有的单个字符都可以视作是回文子串，也就是 `L[i,i]=1`。另外，假如第 `i` 个字符和第 `i+1` 个字符相同，那么也会有 `L[i,i+1]=1`。而对于那些长度超过 2 的子串来说，我们就必须通过 `L[i+1,j-1]=1` 进行判断了：

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty() || s.length() == 1) {
            return s;
        }
        
        int len = s.length();
        int start = 0;
        int longest = 1;
        vector<vector<int>> table(len, vector<int>(len, 0));
        
        for (int i = 0; i < len; i++) {
            table[i][i] = 1;
            if (i + 1 < len) {
                if (s[i] == s[i + 1]) {
                    table[i][i + 1] = 1;
                    start = i;
                    longest = 2;
                }
            }
        }
        
        for (int l = 3; l <= len; l++) {
            for (int i = 0; i + l - 1 < len; i++) {
                int j = i + l - 1;
                if (s[i] == s[j] && table[i + 1][j - 1] == 1) {
                    table[i][j] = 1;
                    start = i;
                    longest = l;
                }
            }
        }
        
        return s.substr(start, longest);
    }
};
```

## 字符串大小写转换

---

### 709. 转换成小写字母

**题目：**

实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。

**解答：**

```cpp
class Solution {
public:
    string toLowerCase(string str) {
        for (int i = 0; i < str.length(); i++) {
            if (str[i] >= 'A' && str[i] <= 'Z') {
                str[i] += 'a' - 'A';
            }
        }
            
        return str;
    }
};
```

## 字符翻译

---

### 804. 唯一摩尔斯密码词

**题目：**

给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，"cab" 可以写成 "-.-.-....-"，(即 "-.-." + "-..." + ".-"字符串的结合)。我们将这样一个连接过程称作单词翻译。

返回我们可以获得所有词不同单词翻译的数量。

**解答：**

这一题用到了`set`结构，该结构的特点就是数据不会重复，且插入与排序的效率很不错，有兴趣的可以去了解一下。

```cpp
class Solution {
public:
    int uniqueMorseRepresentations(vector<string>& words) {
        vector<string> password = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        
        unordered_set<string> set;
        
        for (auto e : words) {
            string temp = "";
            for (auto j : e) {
                temp += password[(int)j - 'a'];
            }
            set.insert(temp);
        }
        
        return set.size();
    }
};
```

## 字符串反转

---

### 344. 反转字符串

**题目：**

请编写一个函数，其功能是将输入的字符串反转过来。

**解答：**

```cpp
class Solution {
public:
    string reverseString(string s) {
        int left = 0, right = s.size() - 1;

        while (left < right) {
            swap(s[left++], s[right--]);
        }
        
        return s;
    }
};
```

### 557. 反转字符串中的单词 III

**题目：**

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

**解答：**

反转每一个单词即可，遇到空格就反转之前的单词。别忘了反转最后一个单词。

```cpp
class Solution {
public:
    string reverseWords(string s) {
        int t = 0;

        for(int i = 0; i <= s.length(); i++){
            if(s[i] == ' '){
                reverse(s.begin() + t, s.begin() + i);
                t = i + 1;
            }
        }

        reverse(s.begin() + t, s.end());

        return s;
    }
};
```

## 字符串的组合

---

### 22. 括号生成

**题目**

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

**解答**

在解答这个问题，首先要搞清楚什么是有效的括号组合。简单点来说，对于当前的字符串，左括号数是肯定要大于等于右括号数的，否则这个字符串就是非法的。反过来说，如果剩下的左括号比右括号多，那么就得减掉当前分支。

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        gener("", res, n, n);
        return res;
    }

    void gener(string s, vector<string>& res, int left, int right){
        // 剩余的左括号比右括号多，字符串非法，剪枝
        if (left > right) { return; }

        if(left == 0 && right == 0) {
            res.push_back(s);
            return;
        }

        // 不停地插入左括号
        if(left > 0) {
            gener(s + "(", res, left - 1, right);
        }

        // 每当剩余的左括号比右括号少时，向字符串插入一个右括号
        if(left < right) {
            gener(s + ")", res, left, right - 1);
        }
    }
};
```

### 921. 使括号有效的最少添加

**题目**

给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。

**解答**

这题其实就是栈计算器的思想，当遇到左括号时入栈，遇到右括号时栈中弹出一个左括号并且总长度减二。由于左右括号的数目是不匹配的，因此取出左括号时需要加个非空判断。最后，字符串剩下的长度就是需要额外添加的括号数。

```cpp
class Solution {
public:
    int minAddToMakeValid(string S) {
        int len = S.length();
        int leftCount = 0;
        
        for (auto e : S) {
            if (e == '(') {
                // 这里我直接记录了左括号数，没有使用栈
                leftCount++;
            }
            
            if (e == ')' && leftCount > 0) {
                leftCount--;
                len -= 2;
            }
        }
        
        return len;
    }
};
```

## 字符串匹配

---

### 890. 查找和替换模式

**题目**

你有一个单词列表 words 和一个模式  pattern，你想知道 words 中的哪些单词与模式匹配。

如果存在字母的排列 p，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。

（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）

返回 words 中与给定模式匹配的单词列表。

你可以按任何顺序返回答案。

**解答**

其实不要想复杂了，既然题目说了每一个字母只映射到另一个字母，不存在两个字母映射同一个字母的情况，那么就说明这一对字母是互相对应的。我们只需准备两个数组，然后在对应的位置存储该字母的映射即可。比如现在是 a 映射到 b，那么如果出现 a 映射到 b，或者 c 映射到 b，那么显然就是错误的。

代码我写的可能不是很详细，各位只需要明白一点，a 与 b 的映射关系是双向的，然后基于这一点进行检查即可。

```cpp
class Solution {
public:
    vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
        for (auto e : words) {
            char *chArray1 = new char[26]();        // chArray1用于标记pattern
            char *chArray2 = new char[26]();        // chArray2用于标记words
            bool isTure = true;
            
            for (int i = 0; i < e.length(); i++) {
                int index1 = pattern[i] - 'a';
                int index2 = e[i] - 'a';
                
                // 当pattern[i]未标记时，检查对应的e[i]是否也未标记。如果都未标记，那么这一对字母就是映射。
                // 如果e[i]已经被标记了，那么就查看e[i]存储的映射是否为pattern[i]，不是的话证明字符串不匹配
                if (chArray1[index1] < 'a') {
                    if (chArray2[index2] < 'a') {
                        chArray1[index1] = e[i];
                        chArray2[index2] = pattern[i];
                        
                    } else if (chArray2[index2] >= 'a' && chArray2[index2] != pattern[i]) {
                        isTure = false;
                        break;
                    }
                    
                } else if (chArray1[index1] >= 'a' && chArray1[index1] != e[i]) {
                    isTure = false;
                    break;
                }
            }
            
            if (isTure) { answer.push_back(e); }
        }
        
        return answer;
    }
    
private:
    vector<string> answer;
};
```