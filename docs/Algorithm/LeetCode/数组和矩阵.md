# 数组和矩阵

这一部分主要和矩阵相关，至于其他含有数组又不好分类的题目，也都一同放在这里。

## 矩阵翻转

---

### 832. 翻转图像（有待改进）

**题目：**

给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。

水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。

反转图片的意思是图片中的 0 全部被 1 替换，1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。

**解答：**

```cpp
class Solution {
public:
    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {
        for (int i = 0; i < A.size(); i++) {
            reverse(A[i].begin(), A[i].end());
            for (int j = 0; j < A[i].size(); j++) {
                A[i][j] = !A[i][j];
            }
        }
        
        return A;
    }
};
```

### 861. 翻转矩阵后的得分

**题目**

有一个二维矩阵 A 其中每个元素的值为 0 或 1 。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

返回尽可能高的分数。

**解答**

由于题目要求尽可能的返回高分数，所以必须保证每一行的第一位是 1。这样不管后面的数怎么变，结果都不会小。在保证了最高位为 1 后，我们就不能够再对行进行移动了，能够动的只能是除第一列以外的列。

移动的标准很简单，当某一列中 0 的个数多于 1 时，就对该列进行移动。

```cpp
class Solution {
public:
    int matrixScore(vector<vector<int>>& A) {
        for (int x = 0; x < A.size(); x++) {
            if (A[x][0] != 1) {
                for (int y = 0; y < A[0].size(); y++) {
                    if (A[x][y] == 0) {
                        A[x][y] = 1;
                        
                    } else {
                        A[x][y] = 0;
                    }
                }
            }
        }
        
        for (int y = 1; y < A[0].size(); y++) {
            int zeroCount = 0;
            int oneCount = 0;
            
            for (int x = 0; x < A.size(); x++) {
                if (A[x][y] == 0) {
                    zeroCount++;
                }
                else {
                    oneCount++;
                }
            }
            
            if (zeroCount > oneCount) {
                for (int x = 0; x < A.size(); x++) {
                    if (A[x][y] == 0) {
                        A[x][y] = 1;
                        
                    } else {
                        A[x][y] = 0;
                    }
                }
            }
        }
        
        int sum = 0;
        
        for(int x = 0; x < A.size(); x++)
        {
            int sumRow = 0;
            for(int y = 0; y < A[0].size(); y++)
            {
                sumRow = sumRow * 2 + A[x][y];
            }
            
            sum += sumRow;
        }
        
        return sum;
    }
};
```

## 矩阵的排列

---

### 807. 保持城市天际线

**题目**

在二维数组 grid 中，grid[i][j] 代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。

最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。请看下面的例子。

建筑物高度可以增加的最大总和是多少？

**解答**

其实这道题目说白了，就是让你求每一行以及每一列的最大值，至于增加的总和，其实就是让你比较 i 行的最大值和 j 列的最大值哪个要小一些，然后将 grid[i][j] 增加到这个数值即可。

```cpp
class Solution {
public:
    int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
        vector<int> row(grid.size());
        vector<int> col(grid[0].size());
        
        int rowLen = row.size();
        int colLen = col.size();
        
        // 每行最大值
        for (int i = 0; i < rowLen; i++) {
            int max = grid[i][0];
            
            for (int j = 1; j < colLen; j++) {
                if (max < grid[i][j]) {
                    max = grid[i][j];
                }
            }
            
            row[i] = max;
        }
        
        // 每列最大值
        for (int j = 0; j < colLen; j++) {
            int max = grid[0][j];
            
            for (int i = 1; i < rowLen; i++) {
                if (max < grid[i][j]) {
                    max = grid[i][j];
                }
            }
            
            col[j] = max;
        }
        
        int sum = 0;
        for (int i = 0; i < rowLen; i++) {
            for (int j = 0; j < colLen; j++) {
                sum += row[i] > col[j] ? col[j] - grid[i][j] : row[i] - grid[i][j];
            }
        }
        
        return sum;
    }
};
```

### 54. 螺旋矩阵

**题目**

给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

**解答**

可以按照螺旋矩阵的走法来计算出该矩阵。首先是从 (0, 0) 开始走到第一行末尾，然后从第一行末尾走到最后一行末尾，再从最后一行末尾走到最后一行开头，最后再走到 (1, 0)。我们可以给行的首尾以及列的首尾加上一个标识，走完一圈之后就往里面缩，最终形成螺旋矩阵。

不过要注意的是，当我们从行尾向行首遍历之前，得先判断矩阵是否已经遍历完了，毕竟矩阵的行和列并不相等。

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        
        if (matrix.empty()) { return result; }
        
        int rowBegin = 0;
        int rowEnd = matrix.size() - 1;
        int colBegin = 0;
        int colEnd = matrix[0].size() - 1;
        
        int len = (rowEnd + 1) * (colEnd + 1);
        
        while (result.size() < len) {
            for (int i = colBegin; i <= colEnd; i++) {
                result.push_back(matrix[rowBegin][i]);
            }
            rowBegin++;
            
            for (int i = rowBegin; i <= rowEnd; i++) {
                result.push_back(matrix[i][colEnd]);
            }
            colEnd--;
            
            if (rowBegin > rowEnd || colBegin > colEnd) { break; }
            
            for (int i = colEnd; i >= colBegin; i--) {
                result.push_back(matrix[rowEnd][i]);
            }
            rowEnd--;
            
            for (int i = rowEnd; i >= rowBegin; i--) {
                result.push_back(matrix[i][colBegin]);
            }
            colBegin++;
        }
        
        return result;
    }
};
```

### 59. 螺旋矩阵 II

**题目**

给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

**解答**

这题的思路和上一题是一样的。

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int rowBegin = 0;
        int rowEnd = n - 1;
        int colBegin = 0;
        int colEnd = n - 1;
        
        int sum = 1;
        
        vector<vector<int>> nums(n, vector<int>(n));
        
        while (sum <= n * n) {
            
            // 向右走行
            for (int i = colBegin; i <= colEnd; i++) {
                nums[rowBegin][i] = sum;
                sum++;
            }
            
            // 减少一行
            rowBegin++;
            
            // 向下走列
            for (int i = rowBegin; i <= rowEnd; i++) {
                nums[i][colEnd] = sum;
                sum++;
            }
            
            // 减少一列
            colEnd--;

            if (rowBegin > rowEnd || colBegin > colEnd) { break; }
            
            // 向左走行
            for (int i = colEnd; i >= colBegin; i--) {
                nums[rowEnd][i] = sum;
                sum++;
            }
            
            // 减少一行
            rowEnd--;
            
            // 向上走列
            for (int i = rowEnd; i >= rowBegin; i--) {
                nums[i][colBegin] = sum;
                sum++;
            }
            
            // 减少一列
            colBegin++;
        }
        
        return nums;
    }
};
```

## 数组相关

---

### 26. 删除排序数组中的重复项

**题目**

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

**解答**

由于不能申请额外的数组，所以我们得用一个变量 pos 存储重复数的位置，然后进行数组遍历。当遇到重复数时，不做任何处理；当遇到不同数时，与之前记录的重复数进行交换即可（也可以直接赋值）。

如果我们从遍历开始没有遇到任何重复的数，那么 pos 就会随着数组遍历一起前进，也就相当于进行了多次原地交换。当重复数出现时，pos 就会停留在原地，这样下次遇到不同数时，就可以用不同数覆盖掉相同数。

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) { return 0; }
        
        int pos = 0;
        int len = nums.size();
        
        for (int i = 1; i < len; i++) {
            if (nums[i] != nums[pos]) {
                pos++;
                nums[pos] = nums[i];
            }
        }
        
        return pos + 1;
    }
};
```