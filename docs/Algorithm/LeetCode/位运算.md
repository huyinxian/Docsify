# 位运算

位运算还是考的蛮多的，很多题目都能够使用位运算巧妙地解决。

## 汉明距离

---

### 461. 汉明距离

**题目：**

两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

**解答：**

该题涉及到位运算。两数按位异或，相同为 0，不同为 1。之后再统计有多少个 1 即可。

```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        int z = x ^ y;
        int sum = 0;
        while (z) {
            // 这一步用于移除z最右边的1，统计1的个数
            z = z & (z - 1);
            sum++;
        }
        
        return sum;
    }
};
```

## 格雷码

---

格雷码是一种特殊的二进制码，特点是相邻的两个代码之间只会有一位二进数不同。打个比方，假如序列按照自然数增长（1、2、3...），那么当数字从 3 变化到 4 时，其二进制会有三位数的变化（011 -> 100）。在某些应用场合而言，机器并不支持这么多位数的同时改变，因此就需要一种新的编码格式来替代。

格雷码与二进制其实是有转换公式的：

```cpp
unsigned int binaryToGray(unsigned int num)
{
    return (num >> 1) ^ num;
}

unsigned int grayToBinary(unsigned int num)
{
    unsigned int mask;
    for (mask = num >> 1; mask != 0; mask = mask >> 1)
    {
        num = num ^ mask;
    }
    return num;
}
```

### 89. 格雷编码

**题目：**

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

示例 1:

    输入: 2
    输出: [0,1,3,2]
    解释:
    00 - 0
    01 - 1
    11 - 3
    10 - 2

    对于给定的 n，其格雷编码序列并不唯一。
    例如，[0,2,3,1] 也是一个有效的格雷编码序列。

    00 - 0
    10 - 2
    11 - 3
    01 - 1

**解答：**

使用上面所述的公式，就能很轻松的求出一串序列对应的格雷码：

```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> vec;
        
        for (int i = 0; i < pow(2, n); i++) {
            vec.push_back((i >> 1) ^ i);
        }
        
        return vec;
    }
};
```

如果不用公式，可以先分析一下格雷码的构成：

    000
    001
    011
    010
    110
    111
    101
    100

上面的列表是三位的格雷码。如果抛开最高位来看，格雷码其实是上下对称的（比如第一个和最后一个是一样的）。这样一来，三位的格雷码其实就相当于在二位格雷码的最高位上加了 0 和 1，而二位格雷码又是在一位格雷码的基础上加了 0 和 1。由此一来，我们就可以使用递归来求出任意位数的格雷码：

```cpp
class Solution {
public:
    
    /*
     * @param n: a number
     * @return: Gray code
     */
    vector<int> grayCode(int n) {
        // write your code here
        if (n <= 0) {
            return vector<int>(1, 0);
        }

        vector<string> strs = grayCodeOfString(n);
        vector<int> result;
        for (int i = 0; i < strs.size(); i++) {
            result.push_back(bitStringToInt(strs[i]));
        }
        return result;
    }

    vector<string> grayCodeOfString(int n) {
        vector<string> strs(pow(2, n), "");
        if (n == 1) {
            strs[0] = "0";
            strs[1] = "1";
            return strs;
        }
        vector<string> last = grayCodeOfString(n - 1);

        for (int i = 0; i < last.size(); i++) {
            strs[i] = "0" + last[i];
            strs[strs.size() - 1 - i] = "1" + last[i];
        }
        return strs;
    }

    int bitStringToInt(string str) {
        int result = 0, pow = 1;
        for (int i = str.size() - 1; i >= 0; i--) {
            result += ((str[i] - '0') * pow);
            pow *= 2;
        }
        return result;
    }
};
```