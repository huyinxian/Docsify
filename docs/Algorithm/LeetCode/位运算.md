# 位运算

位运算还是考的蛮多的，很多题目都能够使用位运算巧妙地解决。

## 汉明距离

---

### 461. 汉明距离

**题目：**

两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

**解答：**

该题涉及到位运算。两数按位异或，相同为 0，不同为 1。之后再统计有多少个 1 即可。

```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        int z = x ^ y;
        int sum = 0;
        while (z) {
            // 这一步用于移除z最右边的1，统计1的个数
            z = z & (z - 1);
            sum++;
        }
        
        return sum;
    }
};
```

## 格雷码

---

格雷码是一种特殊的二进制码，特点是相邻的两个代码之间只会有一位二进数不同。打个比方，假如序列按照自然数增长（1、2、3...），那么当数字从 3 变化到 4 时，其二进制会有三位数的变化（011 -> 100）。在某些应用场合而言，机器并不支持这么多位数的同时改变，因此就需要一种新的编码格式来替代。

格雷码与二进制其实是有转换公式的：

```cpp
unsigned int binaryToGray(unsigned int num)
{
    return (num >> 1) ^ num;
}

unsigned int grayToBinary(unsigned int num)
{
    unsigned int mask;
    for (mask = num >> 1; mask != 0; mask = mask >> 1)
    {
        num = num ^ mask;
    }
    return num;
}
```

### 89. 格雷编码

**题目：**

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

示例 1:

    输入: 2
    输出: [0,1,3,2]
    解释:
    00 - 0
    01 - 1
    11 - 3
    10 - 2

    对于给定的 n，其格雷编码序列并不唯一。
    例如，[0,2,3,1] 也是一个有效的格雷编码序列。

    00 - 0
    10 - 2
    11 - 3
    01 - 1

**解答：**

使用上面所述的公式，就能很轻松的求出一串序列对应的格雷码：

```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> vec;
        
        for (int i = 0; i < pow(2, n); i++) {
            vec.push_back((i >> 1) ^ i);
        }
        
        return vec;
    }
};
```

如果不用公式，可以先分析一下格雷码的构成：

    000
    001
    011
    010
    110
    111
    101
    100

上面的列表是三位的格雷码。如果抛开最高位来看，格雷码其实是上下对称的（比如第一个和最后一个是一样的）。这样一来，三位的格雷码其实就相当于在二位格雷码的最高位上加了 0 和 1，而二位格雷码又是在一位格雷码的基础上加了 0 和 1。由此一来，我们就可以使用递归来求出任意位数的格雷码：

```cpp
class Solution {
public:
    
    /*
     * @param n: a number
     * @return: Gray code
     */
    vector<int> grayCode(int n) {
        // write your code here
        if (n <= 0) {
            return vector<int>(1, 0);
        }

        vector<string> strs = grayCodeOfString(n);
        vector<int> result;
        for (int i = 0; i < strs.size(); i++) {
            result.push_back(bitStringToInt(strs[i]));
        }
        return result;
    }

    vector<string> grayCodeOfString(int n) {
        vector<string> strs(pow(2, n), "");
        if (n == 1) {
            strs[0] = "0";
            strs[1] = "1";
            return strs;
        }
        vector<string> last = grayCodeOfString(n - 1);

        for (int i = 0; i < last.size(); i++) {
            strs[i] = "0" + last[i];
            strs[strs.size() - 1 - i] = "1" + last[i];
        }
        return strs;
    }

    int bitStringToInt(string str) {
        int result = 0, pow = 1;
        for (int i = str.size() - 1; i >= 0; i--) {
            result += ((str[i] - '0') * pow);
            pow *= 2;
        }
        return result;
    }
};
```

## 数组查找

---

### 136. 只出现一次的数字

**题目：**

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**解答：**

这道题可以使用异或运算。异或运算有这几种特性：

* 相同两数异或结果为 0。
* 任意数与 0 异或结果不变。
* 异或运算满足交换律和结合律。

基于上面三种特性，我们可以对数组内所有元素进行异或运算，这样一来相同的数就会归零，最后只剩下那个单独出现的元素。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int num = 0;
        
        for (int i = 0; i < nums.size(); i++) {
            num ^= nums[i];
        }
        
        return num;
    }
};
```

### 查找出现奇数次的数字

**题目**

给定一个非空整数数组，有两个元素出现了奇数次，其他元素出现了偶数次。找出这两个元素。

**解答**

假设这两个元素为 a、b，先对数组进行异或，得到的结果 res 为 `a^b`，然后我们就需要把 a 和 b 区分开。由于 a 和 b 不同，那么 res 肯定不为 0，也就是说 res 这个数的二进制中至少有一位是 1，我们可以根据这一点来进行区分。首先，在 res 的二进制中找到第一个为 1 的位置，记为第 k 位，那么 a 和 b 的区别就是二进制第 k 位不同。现在，我们把数组分成两部分，第一部分只包含二进制中第 k 位为 1 的数，第二部分只包含二进制中第 k 位为 0 的数。那么这个时候 a 和 b 就被分到了两个子数组中，结果也很容易就能够求出了。

```cpp
void FindNumsAppearOnce(int data[], int length, int &num1, int &num2)
{
    if (length < 2)
        return;

    // 获取num1^num2
    int resultExclusiveOR = 0;
    for (int i = 0; i < length; ++ i)
        resultExclusiveOR ^= data[i];

    // 找到二进制中第一个为1的位置k
    unsigned int indexOf1 = FindFirstBitIs1(resultExclusiveOR);
    num1 = num2 = 0;
    for (int j = 0; j < length; ++ j)
    {
        // 将数组划分为两部分
        if(IsBit1(data[j], indexOf1))
            num1 ^= data[j];
        else
            num2 ^= data[j];
    }
}

// 找到当前数的二进制中第一个为1的位置
unsigned int FindFirstBitIs1(int num)
{
    int indexBit = 0;
    while (((num & 1) == 0) && (indexBit < 32))
    {
        num = num >> 1;
        ++indexBit;
    }

    return indexBit;
}

// 判断当前数的二进制第k位是否是1
bool IsBit1(int num, unsigned int indexBit)
{
    num = num >> indexBit;
    return (num & 1);
}
```

## 数字相关

---

### 231. 2的幂

**题目：**

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

**解答：**

2 的幂次方反映到二进制上就是对 1 进行左移，例如 4 就是 1 向左移动 2 位，而 0 就是 1 向右移动 1 位。基于这一特性，2 的幂次方的二进制中最多只能有 1 个 1，所以我们可以用 `n & (n - 1)` 来去除掉数字 n 中最右边的 1（这条公式也可以用来统计某个数的二进制中有多少个 1）。若结果为 0，就代表 n 为 2 的幂次方。

```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n > 0) { return !(n & (n - 1)); }
        else { return false; }
    }
};
```

### 交换两个数

**题目**

给定两个变量，在不创建新变量的情况下交换这两个变量的值。

**解答**

这道题目可以用异或来做，具体做法如下：

```cpp
int a = 1, b = 2;
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

异或满足交换律和结合律，相同两个数异或的结果为 0，任何数和 0 异或结果不变。