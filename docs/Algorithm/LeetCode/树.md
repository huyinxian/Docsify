# 树

树是一种奇特的数据结构，在算法题中占据着非常重要的地位。

## 二叉树遍历

---

二叉树的遍历共有三种形式，如果用递归来实现的话其实非常简单，其原理就类似于深度搜索：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
void dfs(TreeNode *root) {
    visit(root->val);
    dfs(root->left);
    dfs(root->right);
}
```

`visit` 的位置就决定了算法是哪种遍历。

### 前序遍历

前序遍历的顺序是：根节点——左子树——右子树。

递归：

```cpp
class Solution {
public:
    vector<int> result;

    vector<int> preorderTraversal(TreeNode* root) {
        preorder(root);
        return result;
    }

    void preorder(TreeNode* root) {
        if (root)
        {
            result.push_back(root->val);
            preorder(root->left);
            preorder(root->right);
        }
    }
};
```

循环：

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> nodeStack;
        TreeNode *current = root;
        
        while (current || !nodeStack.empty()) {
            if (current) {
                nodeStack.push(current);
                res.push_back(nodeStack.top()-> val);
                current = current->left;
                
            } else if (!nodeStack.empty()) {
                current = nodeStack.top()->right;
                nodeStack.pop();
            }
        }
        
        return res;
    }
};
```

循环顺序：

* 若当前节点 P 不为空，则将 P 入栈并记录其值。
* 将 P 的左子节点置为当前节点 P。
* 若当前节点为空，则将栈顶节点的右子节点置为当前节点 P，并将栈顶出栈。
* 重复上述步骤直至 P 为空且栈也为空。

### 中序遍历

中序遍历：左子树——根节点——右子树。

递归：

```cpp
class Solution {
public:
    vector<int> result;

    vector<int> inorderTraversal(TreeNode* root) {
        inorder(root);
        return result;
    }

    void inorder(TreeNode* root) {
        if (root)
        {
            inorder(root->left);
            result.push_back(root->val);
            inorder(root->right);
        }
    }
};
```

循环：

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> nodeStack;
        TreeNode *current = root;
        
        while (current || !nodeStack.empty()) {
            if (current) {
                nodeStack.push(current);
                current = current->left;
                
            } else if (!nodeStack.empty()) {
                res.push_back(nodeStack.top()-> val);
                current = nodeStack.top()->right;
                nodeStack.pop();
            }
        }
        
        return res;
    }
};
```

简单地解释一下循环：

* 若当前节点 P 不为空，则将 P 入栈。
* 将 P 的左子节点置为当前节点 P。
* 若当前节点为空，则将记录栈顶节点的值，然后让其右子节点置为当前节点 P，最后将栈顶出栈。
* 重复上述步骤直至 P 为空且栈也为空。

### 后序遍历

后序遍历：左子树——右子树——根节点。

递归：

```cpp
class Solution {
public:
    vector<int> result;

    vector<int> postorderTraversal(TreeNode* root) {
        postorder(root);
        return result;
    }

    void postorder(TreeNode* root) {
        if (root)
        {
            postorder(root->left);
            postorder(root->right);
            result.push_back(root->val);
        }
    }
};
```

后序遍历的递归比较麻烦，因为想要访问根节点就必须保证其左右子节点都访问完。网上的一般做法是要标记根节点，让左右子节点都遍历完之后再访问根节点。这样写没啥问题，不过代码太长了不优雅，我这里介绍一种巧妙的方法：

前序遍历的顺序是 `根左右`，后续遍历的顺序是 `左右根`，那么我们其实可以把前序遍历的代码改成 `根右左`，然后对结果进行翻转，就能够轻松地得到后序遍历。

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> nodeStack;
        TreeNode *current = root;
        
        while (current || !nodeStack.empty()) {
            if (current) {
                nodeStack.push(current);
                res.push_back(nodeStack.top()-> val);
                current = current->right;
                
            } else if (!nodeStack.empty()) {
                current = nodeStack.top()->left;
                nodeStack.pop();
            }
        }
        
        // 对结果进行翻转
        reverse(res.begin(), res.end());
        
        return res;
    }
};
```

另外给各位看一下主流的写法：

```cpp
class Solution {
private:
    vector<TreeNode*> NodeStack;
    
    int copyNode(TreeNode *A, TreeNode *B){//A=B
        A->val = B->val;
        A->left = B->left;
        A->right = B->right;
        
        return 0;
    }
    
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        
        TreeNode *workNode = new TreeNode(0);
        if (root != nullptr) {
            copyNode(workNode, root);
        } else {
            delete workNode;
            workNode = nullptr;
        }
        
        while (workNode != nullptr) {
            if (workNode->left != nullptr) {
                NodeStack.push_back(new TreeNode(0));
                copyNode(NodeStack.back(), workNode);
                
                copyNode(workNode, NodeStack.back()->left);
                
                NodeStack.back()->left = nullptr;
                continue;
            }

            if (workNode->right != nullptr) {
                NodeStack.push_back(new TreeNode(0));
                copyNode(NodeStack.back(), workNode);
                
                copyNode(workNode, NodeStack.back()->right);
                
                NodeStack.back()->right = nullptr;
                continue;
            }
            
            result.push_back(workNode->val);
            
            if (NodeStack.empty()) {
                delete workNode;
                workNode = nullptr;
            } else {
                copyNode(workNode, NodeStack.back());
                delete NodeStack.back();
                NodeStack.pop_back();
            }
        }
        
        return result;
    }
};
```

## 二叉树深度问题

---

### 104. 二叉树的最大深度

**题目：**

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**解答：**

这个其实用递归就能做，每次取深度最大的子树然后加一即可。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
```

## 二叉树构建

---

### 654. 最大二叉树

**题目**

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。
通过给定的数组构建最大二叉树，并且输出这个树的根节点。

**解答**

这一题和快排的思想是类似的。首先是找出数组中的最大值，然后将数组分段，左半部的最大值为左子节点，右半部的最大值为右子节点。与快排的区别在于，这个最大值二叉树并不需要排序。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if (nums.size() == 0) { return nullptr; }
        
        int max = nums[0];
        int maxIndex = 0;
        
        int length = nums.size();
        
        for (int i = 0; i < length; i++) {
            if (nums[i] > max) {
                max = nums[i];
                maxIndex = i;
            }
        }
        
        TreeNode *root = new TreeNode(max);
        
        vector<int> v1, v2;
        v1.insert(v1.end(), nums.begin(), nums.begin() + maxIndex);
        v2.insert(v2.end(), nums.begin() + maxIndex + 1, nums.end());
        
        root->left = constructMaximumBinaryTree(v1);
        root->right = constructMaximumBinaryTree(v2);
        
        return root;
    }
};
```

## 剪枝问题

---

### 814. 二叉树剪枝

**题目**

给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。

返回移除了所有不包含 1 的子树的原二叉树。

( 节点 X 的子树为 X 本身，以及所有 X 的后代。)

**解答**

使用后序遍历，将所有为 0 的叶节点剪枝。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        if (root == NULL) { return NULL; }
        
        root->left = pruneTree(root->left);
        root->right = pruneTree(root->right);
        
        if (!root->left && !root->right && root->val == 0) { return NULL; }
        
        return root;
    }
};
```

## 二叉搜索树

---

所谓的二叉搜索树，就是对于每一个节点而言，其值不小于左子树的任何节点，且不大于右子树的任何节点。如果对其使用中序遍历，则遍历结果是一个有序序列。

### 230. 二叉搜索树中第K小的元素

**题目**

给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

**解答**

对二叉搜索树使用中序遍历将得到一个有序序列，我们只需要输出序列的第 k 项即可。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        vector<int> vec;
        inorder(root, vec);
        
        return vec[k - 1];
    }
    
    void inorder(TreeNode *root, vector<int> &vec) {
        if (root) {
            inorder(root->left, vec);
            vec.push_back(root->val);
            inorder(root->right, vec);
        }
    }
};
```