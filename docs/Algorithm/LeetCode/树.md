# 树

树是一种奇特的数据结构，在算法题中占据着非常重要的地位。

## 二叉树遍历

---

二叉树的遍历共有三种形式，如果用递归来实现的话其实非常简单，其原理就类似于深度搜索：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
void dfs(TreeNode *root) {
    visit(root->val);
    dfs(root->left);
    dfs(root->right);
}
```

`visit` 的位置就决定了算法是哪种遍历。

### 前序遍历

前序遍历的顺序是：根节点——左子树——右子树。它在第一次遍历到节点时就会执行操作，如果只是想遍历一棵树可以选择前序遍历。

递归：

```cpp
class Solution {
public:
    vector<int> result;

    vector<int> preorderTraversal(TreeNode* root) {
        preorder(root);
        return result;
    }

    void preorder(TreeNode* root) {
        if (root)
        {
            result.push_back(root->val);
            preorder(root->left);
            preorder(root->right);
        }
    }
};
```

循环：

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> nodeStack;
        TreeNode *current = root;
        
        while (current || !nodeStack.empty()) {
            if (current) {
                nodeStack.push(current);
                res.push_back(nodeStack.top()-> val);
                current = current->left;
                
            } else if (!nodeStack.empty()) {
                current = nodeStack.top()->right;
                nodeStack.pop();
            }
        }
        
        return res;
    }
};
```

循环顺序：

* 若当前节点 P 不为空，则将 P 入栈并记录其值。
* 将 P 的左子节点置为当前节点 P。
* 若当前节点为空，则将栈顶节点的右子节点置为当前节点 P，并将栈顶出栈。
* 重复上述步骤直至 P 为空且栈也为空。

### 中序遍历

中序遍历：左子树——根节点——右子树。它通常用于遍历二叉搜索树，其输出结果为从小到大的有序序列。

递归：

```cpp
class Solution {
public:
    vector<int> result;

    vector<int> inorderTraversal(TreeNode* root) {
        inorder(root);
        return result;
    }

    void inorder(TreeNode* root) {
        if (root)
        {
            inorder(root->left);
            result.push_back(root->val);
            inorder(root->right);
        }
    }
};
```

循环：

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> nodeStack;
        TreeNode *current = root;
        
        while (current || !nodeStack.empty()) {
            if (current) {
                nodeStack.push(current);
                current = current->left;
                
            } else if (!nodeStack.empty()) {
                res.push_back(nodeStack.top()-> val);
                current = nodeStack.top()->right;
                nodeStack.pop();
            }
        }
        
        return res;
    }
};
```

简单地解释一下循环：

* 若当前节点 P 不为空，则将 P 入栈。
* 将 P 的左子节点置为当前节点 P。
* 若当前节点为空，则将记录栈顶节点的值，然后让其右子节点置为当前节点 P，最后将栈顶出栈。
* 重复上述步骤直至 P 为空且栈也为空。

### 后序遍历

后序遍历：左子树——右子树——根节点。它的特点是在对某一节点执行操作时，肯定已经遍历了该节点的左右子节点，所以在删除节点时可以用后序遍历。

递归：

```cpp
class Solution {
public:
    vector<int> result;

    vector<int> postorderTraversal(TreeNode* root) {
        postorder(root);
        return result;
    }

    void postorder(TreeNode* root) {
        if (root)
        {
            postorder(root->left);
            postorder(root->right);
            result.push_back(root->val);
        }
    }
};
```

后序遍历的递归比较麻烦，因为想要访问根节点就必须保证其左右子节点都访问完。网上的一般做法是要标记根节点，让左右子节点都遍历完之后再访问根节点。这样写没啥问题，不过代码太长了不优雅，我这里介绍一种巧妙的方法：

前序遍历的顺序是 `根左右`，后续遍历的顺序是 `左右根`，那么我们其实可以把前序遍历的代码改成 `根右左`，然后对结果进行翻转，就能够轻松地得到后序遍历。

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> nodeStack;
        TreeNode *current = root;
        
        while (current || !nodeStack.empty()) {
            if (current) {
                nodeStack.push(current);
                res.push_back(nodeStack.top()-> val);
                current = current->right;
                
            } else if (!nodeStack.empty()) {
                current = nodeStack.top()->left;
                nodeStack.pop();
            }
        }
        
        // 对结果进行翻转
        reverse(res.begin(), res.end());
        
        return res;
    }
};
```

另外给各位看一下正常的写法：

```cpp
class Solution {
private:
    vector<TreeNode*> NodeStack;
    
    int copyNode(TreeNode *A, TreeNode *B){//A=B
        A->val = B->val;
        A->left = B->left;
        A->right = B->right;
        
        return 0;
    }
    
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        
        TreeNode *workNode = new TreeNode(0);
        if (root != nullptr) {
            copyNode(workNode, root);
        } else {
            delete workNode;
            workNode = nullptr;
        }
        
        while (workNode != nullptr) {
            if (workNode->left != nullptr) {
                NodeStack.push_back(new TreeNode(0));
                copyNode(NodeStack.back(), workNode);
                
                copyNode(workNode, NodeStack.back()->left);
                
                NodeStack.back()->left = nullptr;
                continue;
            }

            if (workNode->right != nullptr) {
                NodeStack.push_back(new TreeNode(0));
                copyNode(NodeStack.back(), workNode);
                
                copyNode(workNode, NodeStack.back()->right);
                
                NodeStack.back()->right = nullptr;
                continue;
            }
            
            result.push_back(workNode->val);
            
            if (NodeStack.empty()) {
                delete workNode;
                workNode = nullptr;
            } else {
                copyNode(workNode, NodeStack.back());
                delete NodeStack.back();
                NodeStack.pop_back();
            }
        }
        
        return result;
    }
};
```

## 二叉树深度问题

---

### 104. 二叉树的最大深度

**题目：**

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**解答：**

这个其实用递归就能做，每次取深度最大的子树然后加一即可。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
```

## 二叉树构建

---

### 654. 最大二叉树

**题目**

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。
通过给定的数组构建最大二叉树，并且输出这个树的根节点。

**解答**

这一题和快排的思想是类似的。首先是找出数组中的最大值，然后将数组分段，左半部的最大值为左子节点，右半部的最大值为右子节点。与快排的区别在于，这个最大值二叉树并不需要排序。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if (nums.size() == 0) { return nullptr; }
        
        int max = nums[0];
        int maxIndex = 0;
        
        int length = nums.size();
        
        for (int i = 0; i < length; i++) {
            if (nums[i] > max) {
                max = nums[i];
                maxIndex = i;
            }
        }
        
        TreeNode *root = new TreeNode(max);
        
        vector<int> v1, v2;
        v1.insert(v1.end(), nums.begin(), nums.begin() + maxIndex);
        v2.insert(v2.end(), nums.begin() + maxIndex + 1, nums.end());
        
        root->left = constructMaximumBinaryTree(v1);
        root->right = constructMaximumBinaryTree(v2);
        
        return root;
    }
};
```

## 剪枝问题

---

### 814. 二叉树剪枝

**题目**

给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。

返回移除了所有不包含 1 的子树的原二叉树。

( 节点 X 的子树为 X 本身，以及所有 X 的后代。)

**解答**

使用后序遍历，将所有为 0 的叶节点剪枝。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        if (root == NULL) { return NULL; }
        
        root->left = pruneTree(root->left);
        root->right = pruneTree(root->right);
        
        if (!root->left && !root->right && root->val == 0) { return NULL; }
        
        return root;
    }
};
```

## 二叉搜索树

---

所谓的二叉搜索树，就是对于每一个节点而言，其值不小于左子树的任何节点，且不大于右子树的任何节点。如果对其使用中序遍历，则遍历结果是一个有序序列。

二叉查找树使用的是二分查找的思想，但是一般的二叉查找树很容易遇到左右子树不平衡的状态。举个例子，如果二叉查找树初始状态为 `9 8 12`，然后依次插入 `7 6 5 4 3 2 1`，那么我们得到的二叉树就是左子树非常大而右子树非常小。这种左右脚不平衡的状态会导致查找效率大打折扣，几乎接近于线性查找。

### 红黑树

红黑树是一种近乎平衡的二叉查找树，它能避免“瘸子”的情况出现。红黑树有以下规则：

* 每个节点要么是黑色，要么是红色。
* 根节点必须是黑色。
* 所有空的叶子节点（null）必须为黑色。
* 如果一个节点是红的，那么它的子节点必须是黑的。
* 对于每个节点，从该点到末端（null）的任何路径，都含有相同个数的黑色节点。

为什么红黑树更好用呢？由第四条规则可知，红色节点不能够连续，因此树的最短路径肯定全是黑色节点。再看第五条规则，因为从任意节点出发的路径都包含相同个数的黑色节点，所以最长路径不会超过最短路径的一倍（避免左右子树过于失衡）。

虽然红黑树提高了搜索效率，但是因为它的规则太多，所以在进行插入和删除操作时往往会破坏红黑树的规则。因此，我们需要在操作后对树进行调整。调整的方法有两类，第一类是改变节点的颜色，第二类是改变树的结构，有**左旋**和**右旋**两种方式。

先来看左旋。左旋是指将父节点的右子树绕父节点逆时针旋转，使得右子树成为父节点，而原本的父节点则成为其右子树的左子节点。图解如下：

![](http://cdn.fantasticmiao.cn/%E5%B7%A6%E6%97%8B%E5%8F%B3%E6%97%8B.gif)

右旋其实是反过来的，它会让左子树成为父节点，然后让原本的父节点成为其左子树的左子节点。

下面看一下左旋右旋的代码的思路：

```cpp
template <class T>
void RBTree<T>::leftRotate(RBTNode<T>* &root, RBTNode<T>* x)
{
    // 设置x的右孩子为y
    RBTNode<T> *y = x->right;

    // 将 “y的左孩子” 设为 “x的右孩子”；
    // 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”
    x->right = y->left;
    if (y->left != NULL)
        y->left->parent = x;

    // 将 “x的父亲” 设为 “y的父亲”
    y->parent = x->parent;

    if (x->parent == NULL)
    {
        root = y;            // 如果 “x的父亲” 是空节点，则将y设为根节点
    }
    else
    {
        if (x->parent->left == x)
            x->parent->left = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
        else
            x->parent->right = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
    }
    
    // 将 “x” 设为 “y的左孩子”
    y->left = x;
    // 将 “x的父节点” 设为 “y”
    x->parent = y;
}

template <class T>
void RBTree<T>::rightRotate(RBTNode<T>* &root, RBTNode<T>* y)
{
    // 设置x是当前节点的左孩子。
    RBTNode<T> *x = y->left;

    // 将 “x的右孩子” 设为 “y的左孩子”；
    // 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”
    y->left = x->right;
    if (x->right != NULL)
        x->right->parent = y;

    // 将 “y的父亲” 设为 “x的父亲”
    x->parent = y->parent;

    if (y->parent == NULL) 
    {
        root = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点
    }
    else
    {
        if (y == y->parent->right)
            y->parent->right = x;    // 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”
        else
            y->parent->left = x;    // (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”
    }

    // 将 “y” 设为 “x的右孩子”
    x->right = y;

    // 将 “y的父节点” 设为 “x”
    y->parent = x;
}
```

上面的代码各位看看思路就行，具体的实现还是要看自己是怎么写的。

说完了调整的方式，再来看看如何实现吧。首先是添加操作，当一颗红黑树中找不到对应的键时，就需要添加新的键了。由于红黑树本身就是一颗二叉查找树，因此当我们按照二叉查找树的规则插入节点时，树其实是有序的。此外，由于左旋、右旋、变色操作都不会影响二叉查找树的有序性，所以我们的唯一目标就是通过上述三种操作来让这棵树重新符合红黑树的规则。

第一步，我们要将插入的节点着色为**红色**。之所以要选择红色，是因为该操作不会违背第五条规则。那么它会违背哪些规则呢？显然，唯一有可能违背的就是第四条规则。

然后，对插入操作进行调整时需要区分父节点是祖父节点的左子节点还是右子节点。以左子节点为例，可能面临的情况有三种：

* 如果叔叔节点（即父节点的兄弟节点）为红色，则父节点和叔叔节点变黑，祖父节点变红，并且把祖父节点作为当前节点。
* 如果叔叔节点为黑色，且插入节点为其父节点的右子节点，则将父节点作为当前节点并左旋，转换为情况三继续处理。
* 如果叔叔节点为黑色，且插入节点为其父节点的左子节点，则将父节点变黑，祖父节点变红并右旋。

上述步骤要一直持续到父节点为黑色为止，如果是右子节点的情况，那么上面的操作是反过来的。

```cpp
template <class T>
void RBTree<T>::insertFixUp(RBTNode<T>* &root, RBTNode<T>* node)
{
    RBTNode<T> *parent, *gparent;

    // 若“父节点存在，并且父节点的颜色是红色”
    while ((parent = rb_parent(node)) && rb_is_red(parent))
    {
        gparent = rb_parent(parent);

        //若“父节点”是“祖父节点的左孩子”
        if (parent == gparent->left)
        {
            // Case 1条件：叔叔节点是红色
            {
                RBTNode<T> *uncle = gparent->right;
                if (uncle && rb_is_red(uncle))
                {
                    rb_set_black(uncle);
                    rb_set_black(parent);
                    rb_set_red(gparent);
                    node = gparent;
                    continue;
                }
            }

            // Case 2条件：叔叔是黑色，且当前节点是右孩子
            if (parent->right == node)
            {
                RBTNode<T> *tmp;
                leftRotate(root, parent);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            // Case 3条件：叔叔是黑色，且当前节点是左孩子。
            rb_set_black(parent);
            rb_set_red(gparent);
            rightRotate(root, gparent);
        } 
        else//若“z的父节点”是“z的祖父节点的右孩子”
        {
            // Case 1条件：叔叔节点是红色
            {
                RBTNode<T> *uncle = gparent->left;
                if (uncle && rb_is_red(uncle))
                {
                    rb_set_black(uncle);
                    rb_set_black(parent);
                    rb_set_red(gparent);
                    node = gparent;
                    continue;
                }
            }

            // Case 2条件：叔叔是黑色，且当前节点是左孩子
            if (parent->left == node)
            {
                RBTNode<T> *tmp;
                rightRotate(root, parent);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            // Case 3条件：叔叔是黑色，且当前节点是右孩子。
            rb_set_black(parent);
            rb_set_red(gparent);
            leftRotate(root, gparent);
        }
    }

    // 将根节点设为黑色
    rb_set_black(root);
}
```

此外，删除操作是不同的，各位有兴趣可以自行去搜索，我之后有时间再更新。

### 230. 二叉搜索树中第K小的元素

**题目**

给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

**解答**

对二叉搜索树使用中序遍历将得到一个有序序列，我们只需要输出序列的第 k 项即可。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        vector<int> vec;
        inorder(root, vec);
        
        return vec[k - 1];
    }
    
    void inorder(TreeNode *root, vector<int> &vec) {
        if (root) {
            inorder(root->left, vec);
            vec.push_back(root->val);
            inorder(root->right, vec);
        }
    }
};
```