# 链表

## 链表相关操作

---

### 206. 反转链表

**题目：**

反转一个单链表。

**解答：**

首先是迭代法，创建一个空的新链表头，将旧链表头的下一节点指向新链表头，然后让旧链表头指向下一节点。这样一来，我们每次都将下一节点放到新链表头，最后得到反转的链表。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next)
            return head;
        
        ListNode* pre = NULL;
        ListNode* cur = head;
        ListNode* next;
        
        while (cur) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        
        head = pre;
        return head;
    }
};
```

递归法与迭代法不同，是从链尾遍历到链头，所以我们得先取到链尾。取到链尾节点后，创建一个新的链头指向该节点，然后将 `head->next->next` 指向 `head`。如果看不懂可以把 `head` 当做倒数第二个节点，而 `head->next->next` 就是链尾所指向的下一节点，这一做法是让链尾指向倒数第二节点，也就是把链表倒过来了。

不过要注意的是，我们得把 `head->next` 置为空，否则倒数第二节点会和链尾成环。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next)
            return head;
        
        ListNode *newHead = reverseList(head->next);
        head->next->next = head;
        head->next = NULL;
        
        return newHead;
    }
};
```

### 61. 旋转链表

**题目：**

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

**解答：**

先遍历整个链表找到链尾，同时记录链表长度 n，然后让链头链尾成环。这时候再继续走 `n - k % n` 个节点，就可以找到旋转链表头的前一个节点（也就是旋转链表的链尾），最后把链头和链尾断开即可。

所谓的旋转，其实就是把链表倒数第 k 个节点当做链表头而已。由于 k 可能会大于 n，因此要对 k 取余数 `k % n`，然后遍历至第 `n - k` 个节点找到旋转链表的链尾。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (!head) { return head; }
        
        ListNode *root = head;
        int n = 1;
        while (root->next) {
            root = root->next;
            n++;
        }
        
        root->next = head;
        int m = n - k % n;
        for (int i = 0; i < m; i++) {
            root = root->next;
        }
        
        ListNode *newHead = root->next;
        root->next = NULL;
        
        return newHead;
    }
};
```

## 链表排序

---

### 148. 排序链表

**题目：**

在 O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序。

**解答：**

基于题目要求的时间复杂度，我们很快就能够想到快排、堆排还有归并排序。由于不能占用过多的空间，因此这里最好用归并排序：

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* SortList(ListNode* head) {
        if (head == NULL || head->next == NULL)
            return head;

        return MergeSort(head);
    }

    ListNode* MergeSort(ListNode* head)
    {
        if (head->next == NULL)
            return head;

        ListNode* pHead, *qHead, *pre;
        pHead = head;
        qHead = head;
        pre = NULL;

        while (qHead != NULL && qHead->next != NULL)
        {
           qHead = qHead->next->next;
           pre = pHead;
           pHead = pHead->next;
        }

        pre->next = NULL;

        ListNode *l, *r;
        l = MergeSort(head);
        r = MergeSort(pHead);

        return Merge(l, r);
    }

    ListNode* Merge(ListNode *l, ListNode *r)
    {
        ListNode *pRes = new ListNode(0);
        ListNode *temp = pRes;

        while (l != NULL && r != NULL)
        {
            if (l->val <= r->val)
            {
                temp->next = l;
                temp = temp->next;
                l = l->next;
            }
            else
            {
                temp->next = r;
                temp = temp->next;
                r = r->next;
            }
        }

        if (l != NULL)
            temp->next = l;
        if (r != NULL)
            temp->next = r;

        temp = pRes->next;
        delete pRes;

        return temp;
    }
};
```