# 链表

## 链表相关操作

---

### 206. 反转链表

**题目：**

反转一个单链表。

**解答：**

首先是迭代法，创建一个空的新链表头，将旧链表头的下一节点指向新链表头，然后让旧链表头指向下一节点。这样一来，我们每次都将下一节点放到新链表头，最后得到反转的链表。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next)
            return head;
        
        ListNode* pre = NULL;
        ListNode* cur = head;
        ListNode* next;
        
        while (cur) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        
        head = pre;
        return head;
    }
};
```

递归法与迭代法不同，是从链尾遍历到链头，所以我们得先取到链尾。取到链尾节点后，创建一个新的链头指向该节点，然后将 `head->next->next` 指向 `head`。如果看不懂可以把 `head` 当做倒数第二个节点，而 `head->next->next` 就是链尾所指向的下一节点，这一做法是让链尾指向倒数第二节点，也就是把链表倒过来了。

不过要注意的是，我们得把 `head->next` 置为空，否则倒数第二节点会和链尾成环。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next)
            return head;
        
        ListNode *newHead = reverseList(head->next);
        head->next->next = head;
        head->next = NULL;
        
        return newHead;
    }
};
```

### 61. 旋转链表

**题目：**

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

**解答：**

所谓的旋转，其实就是把链表倒数第 k 个节点当做链表头而已。我们可以先遍历整个链表找到链尾，同时记录链表长度 n，然后让链头链尾成环。由于 k 可能会大于 n，因此要对 k 取余数 `k % n`，然后往后遍历至第 `n - k` 个节点（即倒数第 k 个数），就可以找到旋转后的链尾。这时我们把链头链尾断开，然后输出新链表头即可。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (!head) { return head; }
        
        ListNode *root = head;
        int n = 1;
        while (root->next) {
            root = root->next;
            n++;
        }
        
        root->next = head;
        int m = n - k % n;
        for (int i = 0; i < m; i++) {
            root = root->next;
        }
        
        ListNode *newHead = root->next;
        root->next = NULL;
        
        return newHead;
    }
};
```

### 插入环形链表

**题目：**

给定一个 num 值，请将其插入到一个有序的环形单链表中，并且保证插入后链表依旧有序。

**解答：**

这道题的思路很简单，创建两个指针 p 和 c，让 p 指向头部，c 指向头部的下一个节点。让 p 和 c 一起往后移动，当出现节点 p 的值不大于 num，并且节点 c 的值不小于 num 时，将 num 插入到 p 和 c 之间。

如果链表为空，那么直接让 num 指向自己即可。如果 p 和 c 转了一圈也没有发现合适的位置，那么就把 num 插入到链表尾（或者说头节点之前）。

### 删除单链表中的节点

**题目：**

给定一个节点 node，但不提供链表的头节点。请将链表中的 node 节点删除。

**解答：**

一般的操作是从头节点开始遍历，找到 node 的前驱节点进行删除。但是由于题目没有提供头节点，因此我们可以把 node 后一个节点的值赋给 node，然后把 node 的后一个节点删除即可。

是不是觉得这种做法看起来很完美呢？然而，这样弄会有一个很严重的问题。假如 node 是链表中的最后一个节点，那么我们无法用下一个节点来代替 node 进行删除。你可能会想，我能不能直接把 node 的内存指向 null 呢？很遗憾，这样也是不行的，null 在内存中是一块特殊区域，你必须要让 node 的前驱节点指向 null 才行。

上述做法本质上其实是值的拷贝，根本就不是对节点进行删除。另外，链表在实际的使用过程中存储的可能都是复杂结构，使用拷贝会消耗资源（或者拷贝本身都是被禁止的）。因此，这道题目其实是无解的，我之所以要记录这道题是因为之前有人被这么问过，以后再遇到的话就告诉面试官这样是不行的。

## 链表排序

---

### 148. 排序链表

**题目：**

在 O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序。

**解答：**

基于题目要求的时间复杂度，我们很快就能够想到快排、堆排还有归并排序。由于不能占用过多的空间，因此这里最好用归并排序：

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* SortList(ListNode* head) {
        if (head == NULL || head->next == NULL)
            return head;

        return MergeSort(head);
    }

    ListNode* MergeSort(ListNode* head)
    {
        if (head->next == NULL)
            return head;

        ListNode* pHead, *qHead, *pre;
        pHead = head;
        qHead = head;
        pre = NULL;

        while (qHead != NULL && qHead->next != NULL)
        {
           qHead = qHead->next->next;
           pre = pHead;
           pHead = pHead->next;
        }

        pre->next = NULL;

        ListNode *l, *r;
        l = MergeSort(head);
        r = MergeSort(pHead);

        return Merge(l, r);
    }

    ListNode* Merge(ListNode *l, ListNode *r)
    {
        ListNode *pRes = new ListNode(0);
        ListNode *temp = pRes;

        while (l != NULL && r != NULL)
        {
            if (l->val <= r->val)
            {
                temp->next = l;
                temp = temp->next;
                l = l->next;
            }
            else
            {
                temp->next = r;
                temp = temp->next;
                r = r->next;
            }
        }

        if (l != NULL)
            temp->next = l;
        if (r != NULL)
            temp->next = r;

        temp = pRes->next;
        delete pRes;

        return temp;
    }
};
```

## 链表运算

---

### 2. Add Two Numbers

**题目：**

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example:

    Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
    Output: 7 -> 0 -> 8
    Explanation: 342 + 465 = 807.

**解答：**

这道题把两个数分别存在了两个链表里，并且数字的顺序是倒过来的。比较容易想到的办法是先把链表倒过来，不过为了提高效率，这里就不反转了，直接用一个新链表来存储结果。对于两个链表相加，如果出现某个链表为空时，直接把这一位当做 0 来处理即可。如果全部算完之后有进位，那么就在最后给结果增加一位即可：

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // res的首位为-1，从它的下一位开始记录结果
        ListNode *res = new ListNode(-1);
        ListNode *cur = res;
        int temp = 0;
        
        while (l1 || l2) {
            // 如果有链表为空，那么直接当做0来处理
            int n1 = l1 ? l1->val : 0;
            int n2 = l2 ? l2->val : 0;
            int sum = n1 + n2 + temp;
            // 记录进位
            temp = sum / 10;
            cur->next = new ListNode(sum % 10);
            cur = cur->next;
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
        }
        
        // 如果temp大于0，那么结果就要进一位
        if (temp) cur->next = new ListNode(1);
        return res->next;
    }
};
```