# 贪心算法

## 贪心算法与动态规划

---

贪心算法和动态规划都是递推算法，也就是通过局部最优解来推导出全局最优解。在贪心算法中，每步做出的决策都无法改变，因为贪心策略是由上一步的最优解推导出下一步的最优解，而上一步的最优解则不做保留。基于这一特性，贪心算法的每一步最优解必定包含上一步最优解。

动态规划则是将问题拆分成多个子问题，由上一个状态推导出下一个状态。动态规划求出的全局最优解一定包含某个局部最优解，但不一定包含上一个局部最优解，因此需要将所有的最优解全部记录下来。动态规划最关键的是状态转移方程，也就是用以求得的局部最优解推导出全局最优解。

要注意的是，贪心算法追求的是尽可能快的求出更好的答案，不能保证求出的解一定是全局最优解，因此无法用来求最大、最小解的问题。像是常见的货币问题，问你某个数额需要多少张货币，贪心算法的策略是先挑大的货币拿，但这不一定就是最优解。

## 常见题型

---

### 55. 跳跃游戏

**题目：**

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

**解答：**

使用贪心算法，维护一个当前所能到达的最大位置。设 maxreach 是当前所能到达的最远距离，那么状态转移方程为 `maxreach = max(maxreach, nums[i] + i)`。maxreach 代表了上一步的最优解，当存在 `maxreach < i` 时，证明无法再往前走了。

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int maxreach = 0;
        for (int i = 0; i < n; i++) {
            // 当i大于maxreach时，说明在该位置上无法跳跃，因此你是无论如何也到不了下一个位置的
            if (i > maxreach) return false;
            maxreach = max(maxreach, i + nums[i]);
            // 当i位置能够跳跃的长度大于数组长度时，返回true
            if (maxreach >= n - 1) return true;
        }
    }
};
```