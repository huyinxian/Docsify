# 数学相关

所有和数字相关但又不好分类的题目都放到了这。

## 自定义的数

---

### 728. 自除数

**题目：**

自除数 是指可以被它包含的每一位数除尽的数。

例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。

还有，自除数不允许包含 0 。

给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。

**解答：**

因为自除数不能包含 0，所以凡是含有 0 的数都不是自除数。之后就按照步骤一个个判断了。

```cpp
class Solution {
public:
    bool judge(int num) {
        int temp = num;
        while (temp) {
            if (temp % 10 == 0 || num % (temp % 10) != 0 ) {
                return false;
            }
            
            temp /= 10;
        }
        
        return true;
    }
    
    vector<int> selfDividingNumbers(int left, int right) {
        vector<int> num;
        
        for (int i = left; i <= right; i++) {
            if (judge(i)) {
                num.push_back(i);
            }
        }
        
        return num;
    }
};
```

### 338. 比特位计数

**题目**

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

**解答**

想要计算一个数的二进制有多少个 1 不难，只需要不断地将它与 1 按位与即可。由于题目要求的是我们一次扫描就完成，所以我们不能够采取按位与的方式。

```cpp
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> res;
        
        res.push_back(0);
        
        for(int i = 1; i < num + 1; i++) {
            res.push_back(res[i / 2] + i % 2);
        }
        
        return res;
    }
};
```

`i/2` 相当于 `i` 右移一位，如果 `i` 是偶数的话，那么末位会是 0，所以 `i` 中 1 的个数是与 `i/2` 相同的；如果 `i` 是奇数，由于末位是 1，所以 `i` 中 1 个数会比 `i/2` 多一个。

## 集合

---

### 78. 子集

**题目**

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

**解答**

这道题目可以用递归来作答，不过其实用循环要更简单一点，做法就是不断地将新的数加入到之前的子集中。比如最开始子集只有空集，新的数为1，那么把1插入到之前的子集后，结果就是 [], [1]。之后再添加新数2，那么插入之后的结果就是 [], [1], [2], [1, 2]。通过不断地累加，就能够利用循环求出子集。

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> childs(1);
        int len1 = nums.size();
        
        sort(nums.begin(), nums.end());
        
        for (int i = 0; i < len1; i++) {
            int len2 = childs.size();
            for (int j = 0; j < len2; j++) {
                childs.push_back(childs[j]);
                childs.back().push_back(nums[i]);
            }
        }
        
        return childs;
    }
};
```

如果要使用递归的话，那么就是要用深度优先搜索。其实解决的方法与求全排列是差不多的，只不过你需要保留所有的子集，而不仅仅是排列。

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> childs;
        vector<int> out;
        
        sort(nums.begin(), nums.end());
        getChild(nums, 0, out, childs);
        
        return childs;
    }
    
    void getChild(vector<int> &nums, int pos, vector<int> &out, vector<vector<int>> &childs) {
        childs.push_back(out);
        
        for (int i = pos; i < nums.size(); i++) {
            out.push_back(nums[i]);
            getChild(nums, i + 1, out, childs);
            out.pop_back();
        }
    }
};
```