## 807. 保持城市天际线

---

**题目**

在二维数组 grid 中，grid[i][j] 代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。

最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。请看下面的例子。

建筑物高度可以增加的最大总和是多少？

**解答**

其实这道题目说白了，就是让你求每一行以及每一列的最大值，至于增加的总和，其实就是让你比较 i 行的最大值和 j 列的最大值哪个要小一些，然后将 grid[i][j] 增加到这个数值即可。

```cpp
class Solution {
public:
    int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
        vector<int> row(grid.size());
        vector<int> col(grid[0].size());
        
        int rowLen = row.size();
        int colLen = col.size();
        
        // 每行最大值
        for (int i = 0; i < rowLen; i++) {
            int max = grid[i][0];
            
            for (int j = 1; j < colLen; j++) {
                if (max < grid[i][j]) {
                    max = grid[i][j];
                }
            }
            
            row[i] = max;
        }
        
        // 每列最大值
        for (int j = 0; j < colLen; j++) {
            int max = grid[0][j];
            
            for (int i = 1; i < rowLen; i++) {
                if (max < grid[i][j]) {
                    max = grid[i][j];
                }
            }
            
            col[j] = max;
        }
        
        int sum = 0;
        for (int i = 0; i < rowLen; i++) {
            for (int j = 0; j < colLen; j++) {
                sum += row[i] > col[j] ? col[j] - grid[i][j] : row[i] - grid[i][j];
            }
        }
        
        return sum;
    }
};
```

## 78. 子集

---

**题目**

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

**解答**

这道题目可以用递归来作答，不过其实用循环要更简单一点，做法就是不断地将新的数加入到之前的子集中。比如最开始子集只有空集，新的数为1，那么把1插入到之前的子集后，结果就是 [], [1]。之后再添加新数2，那么插入之后的结果就是 [], [1], [2], [1, 2]。通过不断地累加，就能够利用循环求出子集。

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> childs(1);
        int len1 = nums.size();
        
        sort(nums.begin(), nums.end());
        
        for (int i = 0; i < len1; i++) {
            int len2 = childs.size();
            for (int j = 0; j < len2; j++) {
                childs.push_back(childs[j]);
                childs.back().push_back(nums[i]);
            }
        }
        
        return childs;
    }
};
```

如果要使用递归的话，那么就是要用深度优先搜索。其实解决的方法与求全排列是差不多的，只不过你需要保留所有的子集，而不仅仅是排列。

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> childs;
        vector<int> out;
        
        sort(nums.begin(), nums.end());
        getChild(nums, 0, out, childs);
        
        return childs;
    }
    
    void getChild(vector<int> &nums, int pos, vector<int> &out, vector<vector<int>> &childs) {
        childs.push_back(out);
        
        for (int i = pos; i < nums.size(); i++) {
            out.push_back(nums[i]);
            getChild(nums, i + 1, out, childs);
            out.pop_back();
        }
    }
};
```

## 654. 最大二叉树

---

**题目**

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。
通过给定的数组构建最大二叉树，并且输出这个树的根节点。

**解答**

这一题和快排的思想是类似的。首先是找出数组中的最大值，然后将数组分段，左半部的最大值为左子节点，右半部的最大值为右子节点。与快排的区别在于，这个最大值二叉树并不需要排序。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if (nums.size() == 0) { return nullptr; }
        
        int max = nums[0];
        int maxIndex = 0;
        
        int length = nums.size();
        
        for (int i = 0; i < length; i++) {
            if (nums[i] > max) {
                max = nums[i];
                maxIndex = i;
            }
        }
        
        TreeNode *root = new TreeNode(max);
        
        vector<int> v1, v2;
        v1.insert(v1.end(), nums.begin(), nums.begin() + maxIndex);
        v2.insert(v2.end(), nums.begin() + maxIndex + 1, nums.end());
        
        root->left = constructMaximumBinaryTree(v1);
        root->right = constructMaximumBinaryTree(v2);
        
        return root;
    }
};
```

## 338. 比特位计数

---

**题目**

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

**解答**

想要计算一个数的二进制有多少个 1 不难，只需要不断地将它与 1 按位与即可。由于题目要求的是我们一次扫描就完成，所以我们不能够采取按位与的方式。

```cpp
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> res;
        
        res.push_back(0);
        
        for(int i = 1; i < num + 1; i++) {
            res.push_back(res[i / 2] + i % 2);
        }
        
        return res;
    }
};
```

`i/2` 相当于 `i` 右移一位，如果 `i` 是偶数的话，那么末位会是 0，所以 `i` 中 1 的个数是与 `i/2` 相同的；如果 `i` 是奇数，由于末位是 1，所以 `i` 中 1 个数会比 `i/2` 多一个。