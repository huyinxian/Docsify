## 807. 保持城市天际线

---

**题目**

在二维数组 grid 中，grid[i][j] 代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。

最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。请看下面的例子。

建筑物高度可以增加的最大总和是多少？

**解答**

其实这道题目说白了，就是让你求每一行以及每一列的最大值，至于增加的总和，其实就是让你比较 i 行的最大值和 j 列的最大值哪个要小一些，然后将 grid[i][j] 增加到这个数值即可。

```cpp
class Solution {
public:
    int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
        vector<int> row(grid.size());
        vector<int> col(grid[0].size());
        
        int rowLen = row.size();
        int colLen = col.size();
        
        // 每行最大值
        for (int i = 0; i < rowLen; i++) {
            int max = grid[i][0];
            
            for (int j = 1; j < colLen; j++) {
                if (max < grid[i][j]) {
                    max = grid[i][j];
                }
            }
            
            row[i] = max;
        }
        
        // 每列最大值
        for (int j = 0; j < colLen; j++) {
            int max = grid[0][j];
            
            for (int i = 1; i < rowLen; i++) {
                if (max < grid[i][j]) {
                    max = grid[i][j];
                }
            }
            
            col[j] = max;
        }
        
        int sum = 0;
        for (int i = 0; i < rowLen; i++) {
            for (int j = 0; j < colLen; j++) {
                sum += row[i] > col[j] ? col[j] - grid[i][j] : row[i] - grid[i][j];
            }
        }
        
        return sum;
    }
};
```

## 78. 子集

---

**题目**

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

**解答**

这道题目可以用递归来作答，不过其实用循环要更简单一点，做法就是不断地将新的数加入到之前的子集中。比如最开始子集只有空集，新的数为1，那么把1插入到之前的子集后，结果就是 [], [1]。之后再添加新数2，那么插入之后的结果就是 [], [1], [2], [1, 2]。通过不断地累加，就能够利用循环求出子集。

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> childs(1);
        int len1 = nums.size();
        
        sort(nums.begin(), nums.end());
        
        for (int i = 0; i < len1; i++) {
            int len2 = childs.size();
            for (int j = 0; j < len2; j++) {
                childs.push_back(childs[j]);
                childs.back().push_back(nums[i]);
            }
        }
        
        return childs;
    }
};
```

如果要使用递归的话，那么就是要用深度优先搜索。其实解决的方法与求全排列是差不多的，只不过你需要保留所有的子集，而不仅仅是排列。

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> childs;
        vector<int> out;
        
        sort(nums.begin(), nums.end());
        getChild(nums, 0, out, childs);
        
        return childs;
    }
    
    void getChild(vector<int> &nums, int pos, vector<int> &out, vector<vector<int>> &childs) {
        childs.push_back(out);
        
        for (int i = pos; i < nums.size(); i++) {
            out.push_back(nums[i]);
            getChild(nums, i + 1, out, childs);
            out.pop_back();
        }
    }
};
```

## 654. 最大二叉树

---

**题目**

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。
通过给定的数组构建最大二叉树，并且输出这个树的根节点。

**解答**

这一题和快排的思想是类似的。首先是找出数组中的最大值，然后将数组分段，左半部的最大值为左子节点，右半部的最大值为右子节点。与快排的区别在于，这个最大值二叉树并不需要排序。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if (nums.size() == 0) { return nullptr; }
        
        int max = nums[0];
        int maxIndex = 0;
        
        int length = nums.size();
        
        for (int i = 0; i < length; i++) {
            if (nums[i] > max) {
                max = nums[i];
                maxIndex = i;
            }
        }
        
        TreeNode *root = new TreeNode(max);
        
        vector<int> v1, v2;
        v1.insert(v1.end(), nums.begin(), nums.begin() + maxIndex);
        v2.insert(v2.end(), nums.begin() + maxIndex + 1, nums.end());
        
        root->left = constructMaximumBinaryTree(v1);
        root->right = constructMaximumBinaryTree(v2);
        
        return root;
    }
};
```

## 338. 比特位计数

---

**题目**

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

**解答**

想要计算一个数的二进制有多少个 1 不难，只需要不断地将它与 1 按位与即可。由于题目要求的是我们一次扫描就完成，所以我们不能够采取按位与的方式。

```cpp
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> res;
        
        res.push_back(0);
        
        for(int i = 1; i < num + 1; i++) {
            res.push_back(res[i / 2] + i % 2);
        }
        
        return res;
    }
};
```

`i/2` 相当于 `i` 右移一位，如果 `i` 是偶数的话，那么末位会是 0，所以 `i` 中 1 的个数是与 `i/2` 相同的；如果 `i` 是奇数，由于末位是 1，所以 `i` 中 1 个数会比 `i/2` 多一个。

## 814. 二叉树剪枝

---

**题目**

给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。

返回移除了所有不包含 1 的子树的原二叉树。

( 节点 X 的子树为 X 本身，以及所有 X 的后代。)

**解答**

使用后序遍历，将所有为 0 的叶节点剪枝。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        if (root == NULL) { return NULL; }
        
        root->left = pruneTree(root->left);
        root->right = pruneTree(root->right);
        
        if (!root->left && !root->right && root->val == 0) { return NULL; }
        
        return root;
    }
};
```

## 861. 翻转矩阵后的得分

---

**题目**

有一个二维矩阵 A 其中每个元素的值为 0 或 1 。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

返回尽可能高的分数。

**解答**

由于题目要求尽可能的返回高分数，所以必须保证每一行的第一位是 1。这样不管后面的数怎么变，结果都不会小。在保证了最高位为 1 后，我们就不能够再对行进行移动了，能够动的只能是除第一列以外的列。

移动的标准很简单，当某一列中 0 的个数多于 1 时，就对该列进行移动。

```cpp
class Solution {
public:
    int matrixScore(vector<vector<int>>& A) {
        for (int x = 0; x < A.size(); x++) {
            if (A[x][0] != 1) {
                for (int y = 0; y < A[0].size(); y++) {
                    if (A[x][y] == 0) {
                        A[x][y] = 1;
                        
                    } else {
                        A[x][y] = 0;
                    }
                }
            }
        }
        
        for (int y = 1; y < A[0].size(); y++) {
            int zeroCount = 0;
            int oneCount = 0;
            
            for (int x = 0; x < A.size(); x++) {
                if (A[x][y] == 0) {
                    zeroCount++;
                }
                else {
                    oneCount++;
                }
            }
            
            if (zeroCount > oneCount) {
                for (int x = 0; x < A.size(); x++) {
                    if (A[x][y] == 0) {
                        A[x][y] = 1;
                        
                    } else {
                        A[x][y] = 0;
                    }
                }
            }
        }
        
        int sum = 0;
        
        for(int x = 0; x < A.size(); x++)
        {
            int sumRow = 0;
            for(int y = 0; y < A[0].size(); y++)
            {
                sumRow = sumRow * 2 + A[x][y];
            }
            
            sum += sumRow;
        }
        
        return sum;
    }
};
```

## 59. 螺旋矩阵 II

**题目**

给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

**解答**

可以按照螺旋矩阵的走法来计算出该矩阵。首先是从 (0, 0) 开始走到第一行末尾，然后从第一行末尾走到最后一行末尾，再从最后一行末尾走到最后一行开头，最后再走到 (1, 0)。我们可以给行的首尾以及列的首尾加上一个标识，走完一圈之后就往里面缩，最终形成螺旋矩阵。

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int rowBegin = 0;
        int rowEnd = n - 1;
        int colBegin = 0;
        int colEnd = n - 1;
        
        int sum = 1;
        
        vector<vector<int>> nums(n, vector<int>(n));
        
        while (sum <= n * n) {
            
            // 向右走行
            for (int i = colBegin; i <= colEnd; i++) {
                nums[rowBegin][i] = sum;
                sum++;
            }
            
            // 减少一行
            rowBegin++;
            
            // 向下走列
            for (int i = rowBegin; i <= rowEnd; i++) {
                nums[i][colEnd] = sum;
                sum++;
            }
            
            // 减少一列
            colEnd--;
            
            // 向左走行
            for (int i = colEnd; i >= colBegin; i--) {
                nums[rowEnd][i] = sum;
                sum++;
            }
            
            // 减少一行
            rowEnd--;
            
            // 向上走列
            for (int i = rowEnd; i >= rowBegin; i--) {
                nums[i][colBegin] = sum;
                sum++;
            }
            
            // 减少一列
            colBegin++;
        }
        
        return nums;
    }
};
```

## 22. 括号生成

---

**题目**

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

**解答**

在解答这个问题，首先要搞清楚什么是有效的括号组合。简单点来说，对于当前的字符串，左括号数是肯定要大于等于右括号数的，否则这个字符串就是非法的。反过来说，如果剩下的左括号比右括号多，那么就得减掉当前分支。

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        gener("", res, n, n);
        return res;
    }

    void gener(string s, vector<string>& res, int left, int right){
        // 剩余的左括号比右括号多，字符串非法，剪枝
        if (left > right) { return; }

        if(left == 0 && right == 0) {
            res.push_back(s);
            return;
        }

        // 不停地插入左括号
        if(left > 0) {
            gener(s + "(", res, left - 1, right);
        }

        // 每当剩余的左括号比右括号少时，向字符串插入一个右括号
        if(left < right) {
            gener(s + ")", res, left, right - 1);
        }
    }
};
```

## 241. 为运算表达式设计优先级

---

**题目**

给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。

**解答**

采用分治算法的思想，对每一个运算符都视为 `左集合 运算符 右集合` 的形式。另外，当集合中只剩下数字时，可以直接将其转换成整数然后压入 vector。

```cpp
class Solution {
public:
    vector<int> diffWaysToCompute(string input) {
        vector<int> num;
        
        // 遍历字符串中的每个字符
        for (int i = 0; i < input.size(); i++) {
            char ch = input[i];
            
            // 当前字符为运算符时，将整个字符串拆分为左右集合，然后分别对左右集合进行递归调用
            if (ch == '+' || ch == '-' || ch == '*') {
                auto num1 = diffWaysToCompute(input.substr(0, i));
                auto num2 = diffWaysToCompute(input.substr(i + 1));
                
                // 左右集合的各种可能计算完毕，将它们按照运算符进行计算
                for (int n1 : num1) {
                    for (int n2 : num2) {
                        if (ch == '+') {
                            num.push_back(n1 + n2);
                        }
                        
                        if (ch == '-') {
                            num.push_back(n1 - n2);
                        }
                        
                        if (ch == '*') {
                            num.push_back(n1 * n2);
                        }
                    }
                }
            }
        }
        
        // 如果字符串遍历完一遍后，num为空，那么证明这个字符串只有数字
        if (num.empty()) {
            num.push_back(stoi(input));
        }
        
        return num;
    }
};
```