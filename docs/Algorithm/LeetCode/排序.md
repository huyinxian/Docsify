# 排序

排序的算法有很多种，例如计数排序、快速排序、堆排序、冒泡排序等等，最好要能够默写出各种类型的排序方法。

## 排序算法汇总

---

首先是 O(N²)复杂度：

### 冒泡排序

冒泡排序就如同其名字一般，从数组首元素开始，依次将相邻的两数进行比较，把较大的数交换到右边。一轮遍历下来，数组最右边的数就是最大值。接下来的工作和第一轮类似，找到剩下元素中的最大值即可，整个过程就如同水泡一般慢慢地往上浮出水面。

### 选择排序

首先，遍历找到数组中的最小值，然后将其与数组首位进行交换即可。接下来则是类似第一轮遍历，找到剩余元素中的最小值，将之与数组第二位进行交换，不断重复直到排序完成。

### 插入排序

* 设 i=0，比较 i 与 i+1，若 i 大于 i+1，那么二者交换位置
* ++i，将 i+1 依次与 0~i 进行比较。只要有某个数比 i+1 大，那么就交换它们两个的位置。一次遍历结束后，0~i+1 是有序的。
* 重复上述过程，直到数列结束

接下来是 O(N*logN)复杂度：

### 快速排序

简单地说下思路，随机取数组中的一个数，把比它小的数放在左边，比它大的数放在右边，然后分别对左右两个子数组进行递归调用即可，这样就算完成一轮排序。

```cpp
/*
 * 快速排序
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     l -- 数组的左边界(例如，从起始位置开始排序，则l=0)
 *     r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)
 */
void quick_sort(int a[], int l, int r)
{
    if (l < r)
    {
        int i,j,x;

        i = l;
        j = r;
        x = a[i];
        while (i < j)
        {
            while(i < j && a[j] > x)
                j--; // 从右向左找第一个小于x的数
            if(i < j)
                a[i++] = a[j];
            while(i < j && a[i] < x)
                i++; // 从左向右找第一个大于x的数
            if(i < j)
                a[j--] = a[i];
        }
        a[i] = x;
        quick_sort(a, l, i-1); /* 递归调用 */
        quick_sort(a, i+1, r); /* 递归调用 */
    }
}
```

### 归并排序

归并排序采用的是分治思想，将问题不断地递归分解为小问题求解，最后再将分解出来的得到的小答案合并在一起得到最终答案。对于归并排序而言，我们可以不断地将数组一分为二，得到若干个单独的元素。之后再将单个元素进行两两合并和排序，不断重复直到形成一个大数组。此时得到的数组就是排序完毕的。

图解如下：

![](http://cdn.fantasticmiao.cn/image/post/LeetCode/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg)

```cpp
void merge_sort(int *data, int start, int end, int *result)
{
    if(1 == end - start)//如果区间中只有两个元素，则对这两个元素进行排序
    {
        if(data[start] > data[end])
        {
            int temp  = data[start];
            data[start] = data[end];
            data[end] = temp;
        }
        return;
    }
    else if(0 == end - start)//如果只有一个元素，则不用排序
        return;
    else
    {
        //继续划分子区间，分别对左右子区间进行排序
        merge_sort(data,start,(end-start+1)/2+start,result);
        merge_sort(data,(end-start+1)/2+start+1,end,result);

        //开始归并已经排好序的start到end之间的数据
        merge(data,start,end,result);

        //把排序后的区间数据复制到原始数据中去
        for(int i = start;i <= end;++i)
            data[i] = result[i];
    }
}

void merge(int *data,int start,int end,int *result)
{
    int left_length = (end - start + 1) / 2 + 1;//左部分区间的数据元素的个数
    int left_index = start;
    int right_index = start + left_length;
    int result_index = start;

    while(left_index < start + left_length && right_index < end+1)
    {
        //对分别已经排好序的左区间和右区间进行合并
        if(data[left_index] <= data[right_index])
            result[result_index++] = data[left_index++];
        else
            result[result_index++] = data[right_index++];
    }

    while(left_index < start + left_length)
        result[result_index++] = data[left_index++];
    while(right_index < end+1)
        result[result_index++] = data[right_index++];
}
```

## 计数排序（桶排序）

---

计数排序其实很简单，你可以用数组记录下每个数字出现的次数，然后依次将它们输出即可。缺点是会占用大量空间，具体优化可以参考哈希表的实现。

### 771. 宝石与石头

**题目：**

给定字符串 J 代表石头中宝石的类型，和字符串 S 代表你拥有的石头。S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

J 中的字母不重复，J 和 S 中的所有字符都是字母。字母区分大小写，因此 a 和 A 是不同类型的石头。

**解答：**

很简单，使用桶排序。一共有 52 种可能，根据字符串 J 来增加对应桶的计数。对于字符串 S，当某一字符对应的桶不为 0 时，总数加一。

```cpp
class Solution {
public:
    int numJewelsInStones(string J, string S) {
        int num[52] = {0};
        int sum = 0;
        
        // 若某一桶不为0，代表这个字符是一种宝石
        for (int i = 0; i < J.length(); i++) {
            if (J[i] >= 'a') {
                num[J[i] - 'a' + 26]++;
            } else {
                num[J[i] - 'A']++;
            }
        }
        
        // 当对应桶不为0时才增加总数
        for (int i = 0; i < S.length(); i++) {
            if (S[i] >= 'a') {
                if (num[S[i] - 'a' + 26] > 0) {
                    sum++;
                }
            } else {
                if (num[S[i] - 'A'] > 0) {
                    sum++;
                }
            }
        }
        
        return sum;
    }
};
```

## 其它与排序相关的问题

---

### 几乎有序数组

**题目：**

已知一个几乎有序的数组，请问用什么方法排序比较好？（注：几乎有序是指当数组排序完毕时，每个元素移动的距离不超过k，而k相对于数组长度来说很小）

**解答：**

首先来看看简单的算法：冒泡排序、选择排序、插入排序。首先，冒泡排序和选择排序与数列的原始排列无关，而对于插入排序而言，原始序列越有序，所花费的时间越少。

至于速度更快的算法，其中归并排序与原始序列无关，其他的也不够稳定，所以我们必须要对算法稍作改进。那么，我便介绍一下改进的堆排序：

* 取 0~k-1，建立一个小根堆
* 弹出栈顶并记录，随后加入下一个数k，调整为小根堆
* 重复上述过程

每次我们调整的是长度为 k 的小根堆，而弹出的栈顶则是我们需要的结果。对与长度为 N 的数组而言，我们一共需要调整 N 次，因此时间复杂度为 O(NlogK)。

### 判断数组中是否存在重复数

**题目：**

判断数组中是否有重复的数，必须保证额外空间复杂度为 O(1)。

**解答：**

由于题目对空间复杂度有要求，因此不能使用哈希表。这里我们可以使用堆排序，不过必须是非递归实现的（递归会占用栈空间）。

### 荷兰国旗问题

**题目：**

对只包含0、1、2的数组进行排序，要求只能使用交换和原地排序，不能用计数排序。

**解答：**

其实这个问题与快速排序很像，我们只需要在数组的两边设置一个 0 区域和一个 2 区域，它们的初始长度为 0。之后遍历整个数组，遇到 1 就跳到下个数，遇到 0 时就将其与 0 区域外第一个数进行交换，然后增加 0 区域的长度并跳到下个数。如果遇到的是 2，那处理方式和 0 类似，但是不要跳到下个数，因为遍历是从左到右进行的，从右边交换来的数有可能是 0，所以必须对交换后的数进行判断。

### 最短排序数组

**题目：**

给定一个数组，查找数组中需要排列的最短子数组长度。

**解答：**

这道题的最优解法如下：

* 从左到右遍历数组，记录当前的最大值。当某个数小于最大值时，记录这个位置 A。
* 从右往左遍历数组，记录当前的最小值。当某个数大于最小值时，记录这个位置 B。

我们在遍历的同时会记录遍历过程的最大值（或者最小值），如果出现某个数小于最大值（或者大于最小值）的情况，证明这个数是需要进行排序的。对此，我们只需要获得最右边位置的 A，以及最左边位置的 B，那么 B 和 A 之间的子数组就是需要进行排序的。

### 最大差值

**题目：**

给定一个数组，排序完毕后，返回相邻两数的最大差值。

**解答：**

这道题目可以用桶排序的思想来做。首先，找到数组中的最大值和最小值，然后按照数组的元素个数，将区间 [min, max) 划分为 n 个桶，然后把元素放进对应的桶中。注意，最大值单独放进一个桶中。

此时，我们共有 n+1 个桶，第一个桶中必有最小值，最后一个桶中只有最大值。由于元素只有 n 个，那么必然会出现空桶。显然，最大差值只可能出现在空桶的两侧，我们无需去考虑同一个桶区间的数，因为同一个桶区间的差值必定小于空桶两侧的差值。

这样一来，我们只需要取后一个桶的最小值与前一个桶的最大值（注意都是非空桶），然后计算出差值即可，遍历一轮下来就能够找到最大差值。