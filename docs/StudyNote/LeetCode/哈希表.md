# 哈希表

## 哈希表的原理

---

哈希表采用键值对进行存储，其最大的优点就是能够快速地存储、查找数据，而代价就是消耗比较多的内存。

哈希表需要建立 key 与 value 的映射，比如哈希表存储的是 int 类型，那么最好的方式是申请一个数组，然后把数组的下标作为 key，数组中的值作为 value。当然，由于 key 可能很大，又或者 key 为其它的类型，因此不能够简单的使用数组来实现。

### 实现思路

哈希查找的第一步就是使用哈希函数，将 key 值转换成 HashCode。比如我们有一个范围为 0 到 n 的数组，那么我们就需要一个能够把 key 值转换为该数组范围内的索引的哈希函数。举个例子，我们在记录电话号码时，可以用前三位和后四位进行组合，这样不太容易重复。

如果键为正整数，那么比较好的做法是使用除留余数法，即对于大小为素数 M 的数组，对于任意正整数 k，计算 k 除以 M 的余数：

```c
#define PRIME 11
int getIntHashCode(int a) {
    return a%PRIME;
}
```

如果键为字符串，那么也可以把字符串当成一个大整数，采用保留除余法：

```c
int getHashCode(char *str, int length) {
    int hash = 0;
    for (int i = 0; i < length; i++) {
        hash = *(str + i) + hash * 31;
    }
    return hash;
}
```

如果觉得处理每个字符太慢，也可以隔几个字符处理一次。但是，这种做法容易导致不同的字符串生成相同的哈希值，也就是产生了冲突。

避免哈希冲突有两种做法，第一种是**拉链法**，也就是把数组中的每一个元素指向一个链表，相同哈希值的元素直接加入到链表中：

![](http://cdn.fantasticmiao.cn/image/post/LeetCode/%E5%93%88%E5%B8%8C%E8%A1%A8/%E6%8B%89%E9%93%BE%E6%B3%95.png)

这种做法需要选择足够大的数组，使得所有的链表都尽可能的短，从而保证查找效率。查找时首先根据哈希值找到对应的链表，然后沿着链表找到对应的键即可。

除了上面这种做法，还有一种**线性探测法**。线性探测法使用大小为 M 的数组来保存 N 个键值对，并且 M > N。我们需要利用数组中的空位来解决哈希冲突：

![](http://cdn.fantasticmiao.cn/image/post/LeetCode/%E5%93%88%E5%B8%8C%E8%A1%A8/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95.png)

在上图中，`Tea Baker` 的哈希值为 153，但是 153 已经被 `Sandra Dee` 占用了。`Sandra Dee` 和 `John Smith` 的哈希值都为 152，但是因为 `John Smith` 先占用了 152，因此它只能后移占据 153。此时，我们可以往下找，发现 154 没被占用，因此可以将 `Tea Baker` 放进去。

线性探测法是开放寻址法中最简单的一种，它的核心思想是当一个键的位置被另一个相同键占据时，将元素存储到下一个为空的位置上。这样一来，当我们查找对应的键时，可能会出现三种情况：

* 该位置上的键符合我们要查找的键。
* 位置为空。
* 该位置上的键与要查找的键不同。

因此，当对应位置上的键不是我们要查找的目标时，我们就需要向下遍历直到找到为止。

线性探测法虽然简单，但是它存在不少问题。线性探测法会导致同类元素聚集，如果存入元素时产生了冲突，那么查找时同样还会遇到冲突。

## 数组相关

---

### 1. 两数之和

**题目**

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素（比如数组第一位是 2，target为 4，你就不能够返回 [0, 0] 作为答案）。

**解答**

由于数组不允许排序，所以为了减少时间复杂度，我们可以采用哈希表来存储出现过的数。我们对数组进行遍历，对于每一个数 `a`，若存在 `b=target-a`，那么就返回答案，否则就把 a 的位置记录下来。

使用暴力搜索会导致超时，同时还会出现使用相同位置元素的情况。哈希表正好也避免了这一种情况。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mMap;
        
        for (int i = 0; i < nums.size(); i++) {
            if (mMap.count(target - nums[i])) {
                return { i, mMap[target - nums[i]] };
            }
            
            mMap[nums[i]] = i;
        }
    }
};
```