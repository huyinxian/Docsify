# 线段树

## 矩形面积

---

### 850. 矩形面积 II

**题目：**

我们给出了一个（轴对齐的）矩形列表 rectangles。对于 rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形 i 左下角的坐标，（x2，y2）是该矩形右上角的坐标。

找出平面中所有矩形叠加覆盖后的总面积。由于答案可能太大，**请返回它对 10 ^ 9 + 7 取模的结果**。

**解答：**

这一题比较经典，具备了扫描、离散化、线段树三个特点。由于给出的矩形较多，枚举肯定是超时的，所以我们必须要换一种思路来看待问题：

![](http://cdn.fantasticmiao.cn/image/post/LeetCode/%E7%BA%BF%E6%AE%B5%E6%A0%91/rectangle_area_ii_pic.png)

如上图所示，我们从左到右扫描所有矩形（从下到上也行），每当遇到矩形的边时将其记录下来，并最终根据这些边划分出多个矩形出来。上图中我们划分出了 S1、S2、S3 这三个矩形，因此矩形的总面积即为这三个矩形面积之和。

有这么简单吗？当然没有！以 S2 为例，你能够直接得到的只有 S2 的宽（两条线的 x 坐标之差），而 S2 的高是多个小矩形的高叠加出来的，所以这个问题的难点就在于如何求出叠加部分的长度。

如果你有做过区间合并的题目，你就会发现这两者其实是一样的。我们可以把小矩形的高视作是由其上下顶点的 y 坐标所构成的区间，然后再对重叠的区间进行合并，并最终计算所有区间的总长度。

```cpp
class Solution {
public:
    int rectangleArea(vector<vector<int>>& rectangles) {
        vector<int> rectX;
        int sumArea = 0, mod = 7 + 1e9;
        // 将所有矩形的x坐标放入rectX
        for (const auto &rectangle : rectangles) {
            rectX.push_back(rectangle[0]);
            rectX.push_back(rectangle[2]);
        }
        
        // x坐标排序，离散化
        sort(rectX.begin(), rectX.end());
        // 去掉重复元素，unique会将容器中重复的元素移到末尾，并返回第一个重复值的迭代器
        rectX.erase(unique(rectX.begin(), rectX.end()), rectX.end());
        // 水平扫描，将复杂的矩形按照x坐标进行切分，计算(rectX[i], rectX[i + 1])之间的面积
        for (int i = rectX.size() - 2; i >= 0; i--) {
            list<pair<int, int>> mergeList;
            for (const auto &rectangle : rectangles) {
                // 如果某个矩形覆盖了(rectX[i], rectX[i + 1])这一段区域，那么将该矩形的y坐标进行合并
                if (rectangle[0] <= rectX[i] && rectangle[2] >= rectX[i + 1]) {
                    addRange(mergeList, rectangle[1], rectangle[3]);
                }
            }
            
            // 由于我们已经把重叠的y区间进行了合并，因此当前区域的矩形高即为mergeList中各区间长度之和
            long height = 0;
            for (const auto &range : mergeList) {
                height += range.second - range.first;
            }
            
            // 矩形的宽度就是rectX[i + 1] - rectX[i]
            sumArea = (sumArea + (rectX[i + 1] - rectX[i]) * height) % mod;
        }
        return sumArea;
    }
    
    // 添加并合并区间
	void addRange(list<pair<int, int>> &mergeList, int left, int right) {
		auto it = mergeList.begin();
        // 找到新区间所要插入的位置，也就是第一个与其产生重叠的区间
        while (it != mergeList.end() && it->second < left) {
            it++;
        }
        // 如果是插入尾部或者两个区间之间，那么直接插入即可
        if (it == mergeList.end() || it->first > right) {
            mergeList.insert(it, { left, right });
        } else {
            // 如果有重叠部分，那么就把新区间合并到现有的区间中
            it->first = min(it->first, left);
            it->second = max(it->second, right);
            auto frontIt = it++;
            // 合并之后的区间又有可能与其它的区间重叠，所以这些也要合并
            while (it != mergeList.end() && frontIt->second >= it->first) {
                frontIt->second = max(it->second, frontIt->second);
                it = mergeList.erase(it);
            }
        }
	}
};
```

上述代码并没有真的去构建一颗线段树，而是采用了区间合并的做法（思想是差不多的）。最后我再提几点要注意的地方：

* 因为是要从左往右扫描，所以一定要先对所有顶点的 x 坐标进行排序，得到离散化的排列。
* 有些顶点的 x 坐标是重复的，要进行去重。

## 区间问题

---

### 715. Range 模块

**题目：**

Range 模块是跟踪数字范围的模块。你的任务是以一种有效的方式设计和实现以下接口。

* `addRange(int left, int right)` 添加半开区间 `[left, right)`，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 `[left, right)` 中尚未跟踪的任何数字到该区间中。
* `queryRange(int left, int right)` 只有在当前正在跟踪区间 `[left, right)` 中的每一个实数时，才返回 true。
* `removeRange(int left, int right)` 停止跟踪区间 `[left, right)` 中当前正在跟踪的每个实数。

**解答：**

这个题目考的是区间的基本操作，理清楚逻辑就好。

```cpp
class RangeModule {
public:
	list<pair<int, int>> mergeList;
	RangeModule() {

	}
    
	void addRange(int left, int right) {
		auto it = mergeList.begin();
		while (it != mergeList.end() && it->second < left) {
			++it;
		}
        
		if (it == mergeList.end() || it->first > right - 1) {
			mergeList.insert(it, { left, right - 1 });
		} else {
			it->first = min(it->first, left);
			it->second = max(it->second, right - 1);
			auto frontIt = it++;
			while (it != mergeList.end() && frontIt->second >= it->first) {
				frontIt->second = max(it->second, frontIt->second);
				it = mergeList.erase(it);
			}
		}
	}
    
	bool queryRange(int left, int right) {
		auto it = mergeList.begin();
		while (it != mergeList.end() && it->second < left) {
			++it;
		}
		if (it == mergeList.end()) {
			return false;
		}

        // 判断新区间中的每个元素是否都在list中
		while (it != mergeList.end() && left < right) {
			if (left > it->second) {
				++it;
			} else if (left >= it->first){
                // 更新
				left = it->second + 1;
			} else {
				break;
			}
		}

		return left >= right;
	}
    
	void removeRange(int left, int right) {
		auto it = mergeList.begin();
		while (it != mergeList.end() && it->second < left) {
			++it;
		}
		if (it == mergeList.end() || it->first >= right) {
			return;
		}

        // 遍历模板区间中的元素，删除list中被覆盖的区间
		while (left != right && it != mergeList.end()) {
            if (it->first >= right) {
				return;
			} else if (it->first >= left) {
				if (right - 1 >= it->second) {
                    // 当前it是[left，right - 1]中的子Range，全部删除
					left = it->second + 1;
					it = mergeList.erase(it);
				} else {
                    // 当前it前半部分是[left，right - 1]中的右半部分
					it->first = right;
					return;
				}
			} else if (it->second > right - 1) {
                // 当前[left，right - 1]是当前it指向的Range的子部分
                // 将it中的[left，right - 1]部分挖去，得到[it->first, left - 1], [right, it->second]
				it = mergeList.insert(it, { it->first, left - 1 });
				++it;
				it->first = right;
				return;
			} else {
                // 当前it的右半部分是[left，right - 1]是左半部分
				int tempLeft = it->second + 1;
				it->second = left - 1;
				left = tempLeft;
                ++it;
			}
		}
	}
};


/**

 * Your RangeModule object will be instantiated and called as such:
 * RangeModule* obj = new RangeModule();
 * obj->addRange(left,right);
 * bool param_2 = obj->queryRange(left,right);
 * obj->removeRange(left,right);
 */
```