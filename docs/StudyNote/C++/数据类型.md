# 数据类型

## typedef与define

---

### 基本用法

typedef 与 define 宏替换不同，它不是简单的文本替换，而是类型替换。我们在开发的过程中，经常会出现类型特别复杂的情况。为了方便，我们通常用 typedef 进行简化，减少工作量。最简单的用法是用别名替换类型名，比如 `typedef int* pI`。很多时候，我们不一定是为了简化类型名，而是为了给类型名起一个别名，方便我们理解。

typedef 的用法有很多，比如在 C 程序中，我们实例化 struct 结构体时，必须用 `struct + 结构体名 + 变量名` 的形式，而在 C++ 中则不需要加上 struct。那么为了简单一点，可以用 typedef 简化，这样一来，我们可以直接使用 POINT 来创建结构体变量：

```cpp
typedef struct Position
{
    int x;
    int y;
}POINT;

POINT p1;
```

当然你也可以定义一些平台无关的的类型：

```cpp
typedef int INT;
// 更换为4个字节的类型
typedef long INT;
```

你可以在编程中直接使用 INT，当平台切换时，你只需要简单的修改一下类型声明就能够做到替换。

### 复杂声明替换

不管声明有多复杂，替换时记住一个规则，就是把变量名留到最后，先替换复杂的声明。下面举一些例子：

```cpp
// 这是一个函数指针的数组
int *(*a[5])(int, char*);
// 替换后
typedef int *(*pFun)(int, char*);
pFun a[5];

// 这是一个函数指针的数组，参数为函数指针
void (*b[10]) (void (*)());
// 先替换参数
typedef void (*pParam)();
// 再替换变量名
typedef void (*pFunc)(pParam);
pFunc b[10];

// 这是一个指向数组的指针，数组由函数指针构成
double(*)() (*e)[9];
// 先替换左边
typedef double(*pFunc)();
// 再替换变量名
typedef pFunc (*pPoint)[9];
pPoint e;
```

知道了如何替换，也要知道如何判断复杂声明。判断方法很简单，从变量名开始解读，先往右，碰到括号再往左，然后再跳出括号判断：

```cpp
// 函数指针
int (*func)(int *p);
// 存储函数指针的数组
int (*func[5])(int *);
// 函数，参数为整型变量和函数指针，返回值为函数指针
int(* z(int x, int (*y)(int)))(int);
```

### typedef与define的区别

其实弄明白了之后还是很简单的。举个例子：

```cpp
#define void* VP1
typedef void* VP2;
const VP1 p1;       // const void *p1
const VP2 p2;       // void *const p2
```

我在修饰符一章中讲过，修饰符的先后顺序通常是没有影响的，所以 const 和 VP2 修饰的都是 p2 本身，而 define 就只是文本替换而已。

另外需要注意的是，由于 define 是直接替换，所以它不是类型安全的。

## 全局变量、静态变量、局部变量

---

### 从作用域进行区分

C++ 的作用域可以分为六种：全局作用域、局部作用域、语句作用域、类作用域、命名空间作用域、文件作用域。

全局变量具有全局作用域。只要在一个源文件中定义全局变量，就可以作用于所有的源文件。如果其他源文件需要再次定义同名全局变量时，需要使用 `extern` 关键字。

静态全局变量仅作用于当前源文件，其他文件中即使定义了同名静态全局变量也不会相互影响。

局部变量只有局部作用域。它只在函数执行期间存在，函数执行完毕时将被销毁。

静态局部变量也只有局部作用域。它只被初始化一次，且从初始化过后到程序结束时都会存在。静态局部变量仅对定义自己的函数体可见。

### 静态变量的初始化时机

全局变量、静态全局变量、类的静态成员会在 main 执行之前的静态初始化过程中分配内存并初始化，所以**类的静态成员必须要在类体外进行初始化**。局部静态变量（一般指函数体内的静态变量）同样也是在 main 执行之前分配内存，但它的初始化是在第一次使用它时进行的。

对于 C++，静态成员在程序开始前就要存在，所以需要实际地分配空间。由于类声明只是声明一个类的“尺寸和规格”，并不会实际地进行内存分配，所以在类中初始化静态成员是错误的，必须要在类体外。此外，它也不能够在头文件中的类声明外进行初始化，因为这样会造成多个使用该类的源文件对其重复定义。

### 从分配内存进行区分

全局变量、静态变量都是存在全局区，局部变量则存在于栈区。全局变量和静态全局变量的存储方式都是以静态方式存储，二者的区别仅在于作用域。不过相比而言，静态全局变量只作用于一个源文件，因此不会与其他源文件发生冲突，所以最好优先选择静态全局变量。

### 总结

将知识归纳为以下几点：

* 全局变量、静态全局变量、类静态成员都是在 main 执行之前分配内存并初始化，静态局部变量在 main 执行之前分配内存，在第一次使用时初始化。
* 静态变量只进行一次初始化，直到程序结束后才释放。
* 静态全局变量只能在一个源文件中访问，不能在其他文件中访问，哪怕使用 `extern` 也不行。
* 静态函数只能在本文件使用。
* 全局静态变量和局部静态变量都存在全局区，未显示初始化时自动赋值为 0。
* 类静态成员必须要在类体外进行初始化，类中只能够进行声明。