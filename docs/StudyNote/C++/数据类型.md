# 数据类型

## typedef与define

---

### 基本用法

typedef 与 define 宏替换不同，它不是简单的文本替换，而是类型替换。我们在开发的过程中，经常会出现类型特别复杂的情况。为了方便，我们通常用 typedef 进行简化，减少工作量。最简单的用法是用别名替换类型名，比如 `typedef int* pI`。很多时候，我们不一定是为了简化类型名，而是为了给类型名起一个别名，方便我们理解。

typedef 的用法有很多，比如在 C 程序中，我们实例化 struct 结构体时，必须用 `struct + 结构体名 + 变量名` 的形式，而在 C++ 中则不需要加上 struct。那么为了简单一点，可以用 typedef 简化，这样一来，我们可以直接使用 POINT 来创建结构体变量：

```cpp
typedef struct Position
{
    int x;
    int y;
}POINT;

POINT p1;
```

当然你也可以定义一些平台无关的的类型：

```cpp
typedef int INT;
// 更换为4个字节的类型
typedef long INT;
```

你可以在编程中直接使用 INT，当平台切换时，你只需要简单的修改一下类型声明就能够做到替换。

### 复杂声明替换

不管声明有多复杂，替换时记住一个规则，就是把变量名留到最后，先替换复杂的声明。下面举一些例子：

```cpp
// 这是一个函数指针的数组
int *(*a[5])(int, char*);
// 替换后
typedef int *(*pFun)(int, char*);
pFun a[5];

// 这是一个函数指针的数组，参数为函数指针
void (*b[10]) (void (*)());
// 先替换参数
typedef void (*pParam)();
// 再替换变量名
typedef void (*pFunc)(pParam);
pFunc b[10];

// 这是一个指向数组的指针，数组由函数指针构成
double(*)() (*e)[9];
// 先替换左边
typedef double(*pFunc)();
// 再替换变量名
typedef pFunc (*pPoint)[9];
pPoint e;
```

知道了如何替换，也要知道如何判断复杂声明。判断方法很简单，从变量名开始解读，先往右，碰到括号再往左，然后再跳出括号判断：

```cpp
// 函数指针
int (*func)(int *p);
// 存储函数指针的数组
int (*func[5])(int *);
// 函数，参数为整型变量和函数指针，返回值为函数指针
int(* z(int x, int (*y)(int)))(int);
```

### typedef与define的区别

其实弄明白了之后还是很简单的。举个例子：

```cpp
#define void* VP1
typedef void* VP2;
const VP1 p1;       // const void *p1
const VP2 p2;       // void *const p2
```

我在修饰符一章中讲过，修饰符的先后顺序通常是没有影响的，所以 const 和 VP2 修饰的都是 p2 本身，而 define 就只是文本替换而已。

另外需要注意的是，由于 define 是直接替换，所以它不是类型安全的。

## 全局变量、静态变量、局部变量

---

### 从作用域进行区分

C++ 的作用域可以分为六种：全局作用域、局部作用域、语句作用域、类作用域、命名空间作用域、文件作用域。

全局变量具有全局作用域。只要在一个源文件中定义全局变量，就可以作用于所有的源文件。如果其他源文件需要再次定义同名全局变量时，需要使用 `extern` 关键字。

静态全局变量仅作用于当前源文件，其他文件中即使定义了同名静态全局变量也不会相互影响。

局部变量只有局部作用域。它只在函数执行期间存在，函数执行完毕时将被销毁。

静态局部变量也只有局部作用域。它只被初始化一次，且从初始化过后到程序结束时都会存在。静态局部变量仅对定义自己的函数体可见。

### 静态变量的初始化时机

全局变量、静态全局变量、类的静态成员会在 main 执行之前的静态初始化过程中分配内存并初始化，所以**类的静态成员必须要在类体外进行初始化**。局部静态变量（一般指函数体内的静态变量）同样也是在 main 执行之前分配内存，但它的初始化是在第一次使用它时进行的。

对于 C++，静态成员在程序开始前就要存在，所以需要实际地分配空间。由于类声明只是声明一个类的“尺寸和规格”，并不会实际地进行内存分配，所以在类中初始化静态成员是错误的，必须要在类体外。此外，它也不能够在头文件中的类声明外进行初始化，因为这样会造成多个使用该类的源文件对其重复定义。

### 从分配内存进行区分

全局变量、静态变量都是存在全局区，局部变量则存在于栈区。全局变量和静态全局变量的存储方式都是以静态方式存储，二者的区别仅在于作用域。不过相比而言，静态全局变量只作用于一个源文件，因此不会与其他源文件发生冲突，所以最好优先选择静态全局变量。

### 总结

将知识归纳为以下几点：

* 全局变量、静态全局变量、类静态成员都是在 main 执行之前分配内存并初始化，静态局部变量在 main 执行之前分配内存，在第一次使用时初始化。
* 静态变量只进行一次初始化，直到程序结束后才释放。
* 静态全局变量只能在一个源文件中访问，不能在其他文件中访问，哪怕使用 `extern` 也不行。
* 静态函数只能在本文件使用。
* 全局静态变量和局部静态变量都存在全局区，未显示初始化时自动赋值为 0。
* 类静态成员必须要在类体外进行初始化，类中只能够进行声明。

## 四种类型转换

---

C 风格的类型强转很简单，使用 `()` 即可。但是 C 风格强转有很多问题，因为它可以在任意类型之间转换，比如把指向常量的指针转成指向变量的指针，把指向基类的指针变成指向派生类的指针。C++ 为了克服这些问题，引入了四种新的类型转换。

### static_cast

`static_cast` 可以实现 C++ 中基础数据类型之间的转换，比如 enum、struct、int、char、float 等。只要不包含底层 const，都可以使用这种转换。

比如将整型改成浮点数：

```cpp
double dval = static_cast<double>(j) / i;
```

如果你想要把一个较大的数据类型赋值给较小的类型，且不在乎精度丢失，那么你可以使用 static_cast。

此外，由于 void* 指针不能够直接赋值给其他类型指针，因此我们可以使用 static_cast 进行强制转换：

```cpp
double d = 3.2;
void *p = &d;
double *dp = static_cast<double *>(p);
```

如果你要这么做的话，你得确保强转后得到的类型就是原指针所指向的类型，否则你在使用时会出错。

### const_cast

`const_cast` 只能去除底层 const：

```cpp
const char *pc;
char *p = const_cast<char *>(pc);
```

但要注意一点，你必须确保原指针指向的不是一个常量。const_cast 可以理解为编译器不再阻止我们对某个对象进行写操作，假如该对象本身不是一个常量，那么这种操作是合法的。但假如该对象本身是一个常量，那么当你强制去除掉底层 const 并对其进行写操作时，就会产生未知的后果。

### reinterpret_cast

`reinterpret_cast` 从字面意思上来理解就是“重新解释”，此类强转即为数据的二进制形式重新解释，但不改变其值。它类似于 C 风格强转，可以将任意内置类型转换成其他的类型，也可以将任意指针类型转换成其他指针类型，甚至于可以将内置数据类型转换成指针。由于它没有考虑类型安全和常量的情况，因此尽量不要使用。

```cpp
int *ip;
char *pc = reinterpret_cast<char *>(ip);
```

上述代码中，reinterpret_cast 将一个指向 int 的指针转换成了指向 char 的指针。如果你把 pc 当成了普通的字符串指针进行使用，那么极有可能会发生运行时错误：

```cpp
string str(pc);
```

虽然我们将 ip 强制解释为指向 char 的指针，但它本质上还是指向整型数的指针。上述的操作显然是错误的。

reinterpret_cast 是很危险的，它能够将类型进行转换，并且还不会让编译器报错。如果你对于涉及到的类型和转换过程不是很了解，那么建议是不要使用这种转换方式。

### dynamic_cast

`dynamic_cast` 属于动态类型转换，是在运行时处理的，并且要接受类型检查。dynamic_cast 不能够用于内置的数据类型强转，只能用于类的指针、类的引用或者 void* 指针。

dynamic_cast 在转换成功时会返回类的指针或引用，失败时会返回 NULL。如果要使用这种强转，那么必须要保证基类中有虚函数，否则编译是通不过的。为什么要有虚函数呢？这是因为如果类中有虚函数，就说明它有想要让基类指针或者引用指向派生类的情况，此时转换才有意义。由于该强转是运行时进行类型检查，而这个信息会存在虚函数表中，因此需要定义虚函数（不懂的话可以去看一下虚函数）。

在进行上行转换时（将派生类指针转换成指向基类的指针），由于这属于隐式转换，所以 dynamic_cast 和 static_cast 是一样的效果。当进行下行转换时（把指向基类的指针转换成指向派生类的指针），dynamic_cast 会进行运行时检查，确保二者之间有继承关系，比 static_cast 更安全。

dynamic_cast 同样可以将空指针 void* 转换成其他类型的指针。