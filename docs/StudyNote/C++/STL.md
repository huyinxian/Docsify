# STL

C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。

模板库有以下三个组件：

* 容器：用于管理某一类对象的集合，常用的有 list、vector、map 等。
* 算法：作用于容器，包括对容器进行排序、初始化、搜索、转换等操作。
* 迭代器：迭代器用于遍历容器内的元素。

## 常见的STL底层数据结构

---

### 数组

数组的优点为随机访问效率很高（可以使用 `[]` 运算符），适合存储需要经常进行访问的元素。

数组的缺点如下：

* 插入删除效率低（需要把元素往后移）
* 会浪费内存（数组申请的空间是连续的，如果没有规划好大小会造成浪费）

### 链表

常用的有单链表和双向链表。单链表只有一个指向下一节点的指针（next），而双向链表还会多一个指向上一节点的指针（prev）。

双向链表与单链表的比较：

* 在进行插入和删除时，双向链表可以原地进行，比单链表要快。
* 双向链表需要多存储一个指向上一节点的指针，比单链表占据的空间要大。
* 双向链表可以进行双向遍历，单链表只能向后遍历。

数组与链表的比较：

* 数组的存储空间为连续的，需要指定大小，而链表的存储空间为链式且可以动态扩展，在空间利用率上要远大于数组。
* 链表不支持随机访问（没有 `[]`）。

?> 有的双向链表会让头尾相连，形成环状双向链表。

### 哈希表

哈希表是一种以键值对的形式存储元素，并且支持快速添加与访问的数据结构。具体原理请看我的数据结构笔记。

### 红黑树

红黑树是一种近似平衡的二叉查找树，有着较高的插入效率和访问效率，并且能够输出有序序列。具体原理请看我的数据结构笔记。

## STL容器

---

### vector

vector 是常用的容器，其底层数据结构为**动态数组**，在堆上分配空间。vector 会随着元素的加入逐渐扩大空间，所以不用像数组那样一开始就申请一个很大的空间。

vector 的动态扩展并不是在原空间基础上增加，而是重新开辟一个原空间两倍大小的新空间，并把原空间的元素拷贝到新空间。完成拷贝后，原空间会被释放，因此**指向原空间的迭代器会失效**。vecotr 本身具有保留空间，即使减小容量也不会释放掉保留空间。

当向动态数组的开头和中间处进行插入删除操作时，需要把操作位置之后的元素全部往后移动。如果你的元素是结构体或者类，那么在移动的同时还会进行构造和析构，效率比较低（vecotr 中最好存类的指针，不要存实体）。另外，由于 vector 本身是数组，所以它访问任意元素的效率都为 O(1)。

vector 具有容量（capacity）的概念，它代表了 vector 当前所分配的空间大小，而尺寸（size）代表的则是 vector 中实际的元素个数。

vector 常用于存储需要经常进行随机访问的内容，并且不需要频繁对元素进行插入删除操作。

### list

list 的底层数据结构为**环状双向链表**，在堆上分配空间。list 可以进行动态空间分配，并且它在执行插入和删除操作时非常快。

由于双向链表本身的结构问题，导致 list 随机访问效率很低，需要从头进行遍历。

list 常用于存储需要频繁进行插入删除的对象，如果对象不大，最好用 vector 代替。

### deque

deque 是一种双向开口的连续性空间，底层数据结构为**一个中央控制器和多个缓冲区**，在堆上分配空间。相比于 vector，它的优点为：

* deque 可以在常数级时间内对首尾两端进行插入和删除操作。
* deque 没有容量的概念，因为它是将多个连续的空间组合在一起，并且随时可以链接新的空间，无需像 vector 那样重新分配。

deque 与 vector 一样具有保留空间，这块空间的元素都为指针，指向一块连续的空间（缓冲区），所以缓冲区才是 deque 真正用来存储的地方。

虽然 deque 避免了“重新分配、复制元素、释放原空间”的问题，但是其管理空间的迭代器较为复杂，数据结构的设计及迭代器前进后退等操作都颇为繁琐。

deque 支持 `[]` 操作符，其随机访问效率没有 vecotr 快（因为它要处理堆之间的跳转）。deque 在首尾两端进行添加时，性能很高。

对 vector、list、deque 的总结如下：

* vecotr 可以快速地在尾部添加和删除元素，并且支持快速随机访问。
* list 可以在任意位置进行快速地添加和删除元素，但不支持随机访问（需要从头遍历）。
* deque 可以在首尾两端快速地添加和删除元素，其随机访问速度比 vector 慢。由于 deque 不要求连续空间，所以其保存的元素要比 vecotr 多。

### stack

stack（栈）是一种先进后出的数据结构，只允许对栈顶元素进行操作，且不允许进行遍历。

stack 的实现很简单，使用 list 或者 deque 就可以做到（封闭头部即可）。

### queue

queue（队列）是一种先进先出的数据结构，只允许在队尾添加元素以及在队首删除元素。

queue 的实现也可以使用 deque，即封住前端入口和尾端出口即可。

### set和multiset

set 的特性是所有元素都会根据元素的键进行排序。set 并不像 map 那样拥有键值对（key-value），set 的键就是元素的值，所以 set 中不会包含有重复的值。

set 的底层实现采用的是**红黑树**，其自动排序的效率很不错。

multiset 的用法和 set 差不多，唯一的区别是 multiset 允许出现重复的键值。

### map和multimap

map 同样也会将所有元素按照元素的键进行排序。map 拥有键值对，一个键对应一个实值，所以 map 中不允许出现同样的键。

map 的底层实现同样采用的是**红黑树**。

multimap 用法和 map 一样，不过它允许键重复。

### unordered_map、unordered_set、unordered_multimap、unordered_multiset

它们的使用方法和原版是一样的，唯一的区别就是它们的底层数据结构采用了**哈希表**。哈希表的查询效率要比红黑树高，但其序列是**无序**的。