# 修饰符

## const

---

### 基本作用

讲一下 C++ 里面比较容易搞混的 const 修饰符。const 用于修饰变量或者类成员方法，对于被修饰的变量而言，其值无法更改；对于被修饰的类成员方法而言，其表明该方法不会修改该类任何成员的值。常量成员方法的意义在于它能够被常量对象所调用，比如：

```cpp
const List list;
list.GetLength();
```

在这里，我们声明了一个常量对象 list，如果用它来调用一些类成员方法的话，很可能就会导致类成员被更改。显然，这与 const 的定义是冲突的，但我们又不可能禁止常量对象调用类方法。此时，我们就可以声明常量成员方法，以此保证类成员不会被改变。

?> 如果变量被修饰为 mutable，那么常量成员方法可以对其进行更改。

### 顶层const与底层const

类型修饰符的先后顺序通常是没有什么影响的，但对于指针这一类复杂的数据类型则会有些不同。看下面的三个例子：

```cpp
const int *p1;          // 指向常量的指针，指针指向的地址中的内容不能改变
int *const p2;          // 常量指针，指针所指向的地址不能改变
const int *const p3;    // 指向常量的常量指针，指针指向的地址不能改变，地址中的内容也不能改变
```

简单点来说，如果指针对于本身进行限定，那么就顶层 const；如果对于指向的内容进行限定，那么就是底层 const。

为什么要这么分呢？可以看下面的例子：

```cpp
int num = 1;
const int *p1 = &num;   // 指向常量的指针
int *p2 = p1;           // 错误，p1指向的是常量，p2指向的是变量
const int *p3 = p1;     // 正确，二者都指向常量
```

除此之外，使用 const_cast 强制转换时也要分清顶层和底层，因为这个转换只能用于底层 const：

```cpp
int num = 1;
const int *p1 = &num;
*p1 = 2;                            // 错误，p1是指向常量的指针
int *p2 = const_cast<int *>(p1);    // 正确，const_cast可以去除底层const，但最好确保num是变量而不是常量
```

可能有些人对于第一个注释有些不太理解，明明 p1 指向的 num 是变量，为什么说它指向的是常量呢？这里我们需要明确一点，**const 是类型修饰符**，我们限制的只是指针本身，强制要求它不去更改所指向的内容而已。因此，指针所指向的是不是常量其实没有什么区别。

### 复杂类型的判断

既然都说到了复杂类型，顺便也讲一讲经常弄混的问题吧。看看下面的例子：

```cpp
int *a[10];     // []优先级高于*，a为数组，数组内为指向整型的指针
int (*a)[10];   // ()优先级高于[]，a为指针，指向的是存储整型变量的数组
```

对于这类问题，判断原则是先看右边再看左边，有括号先看括号。