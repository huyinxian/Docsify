# 反射

反射是 .Net 的重要机制，我们可以使用反射在程序运行时获取程序或程序集中的每一个类型（类、结构、委托、接口、枚举等），动态创建出对象，并且调用它的方法。

## 反射的基本概念

---

### 什么是反射

.Net 应用程序由程序集、模块、类型组成，而反射则通过一种编程方式，让开发者可以在程序运行期间获得这几个组成部分的相关信息。

举个例子，Assembly 类可以获取正在运行的装配件信息，以及在装配件中查找类型信息，并创建该类型的实例。Type 类则可以获取对象的类型信息，通常包含方法、构造器、属性等。MethodInfo 包含方法的信息，可以获取该方法的名称、参数、返回值等，并能够调用该方法。

### 装配件

可能有人对于装配件不太了解，我这里解释一下。所谓的装配件就是 .Net 的最小执行单位，.dll、.exe 都是装配件。我们在代码里面通常会声明命名空间和类，而要想获取到一个类，就必须提供该类型的地址。

那么问题来了，如果我只知道类型的名称，能否使用这个类呢？答案是可以的，只要使用反射就行了。

### 反射有什么用

上面介绍一大堆反射的概念，看起来好像很厉害的样子，但它到底有什么用呢？明明我开发的时候就能够把代码全部写好，为什么非得到运行时去获取类型呢？这样做不仅麻烦，而且还会影响程序的运行效率。

我们不妨来看一看，获取到的类型信息到底有什么用：

```
public interface IMediaFormat
{
    string Extension { get; }
    Decoder GetDecoder();
}
```

比如上面这是一个媒体播放器的接口，可以用于扩展播放器所能支持的媒体文件类型。开发者对于此类接口有一个规定，如果用户需要扩展解码插件，那么就必须实现接口中的 `GetDecoder()` 方法，也就是需要返回一个解码器。这样一来，如果市面上出现了一种新的媒体文件，那么用户可以继承该接口，并自行编写该类型的解码器。

我们在编写媒体播放器时，并不知道将来可能出现哪些新的文件类型。但没关系，我们可以让用户把自定义的解码器名称写到配置表中，在运行时读取配置表动态创建媒体格式对象，然后将其转换成 `IMediaFormat` 接口。这样一来，我们就可以通过 `GetDecoder()` 获取到自定的解码器。由于 C# 中提供了 `Type` 等类型，因此我们从头到尾都不需要知道新类型是什么，直接用反射转换即可，非常方便。

除此之外，像 C# 和 Lua 交互时也是使用的反射。当然，有些平台并不支持反射功能，这种时候就只能把 C# 代码转换成静态文件使用。