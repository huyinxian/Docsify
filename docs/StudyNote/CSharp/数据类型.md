# 数据类型

## 基元类型

---

基元类型是指编译器直接支持的数据类型。基元类型会直接映射到 Framework 库中存在的类型。举个例子：

```csharp

int a = 0;
System.Int32 b = 0;
int c = new int();
System.Int32 d=new Int32();
```

如果查看 IL 代码，你会发现上面的这四条语句其实是等价的。由于基元类型会映射到 Framework（FCL）中存在的类型，因此你用 int 或者 System.Int32 其实是一样的，编译器会自动完成转换。很多人经常纠结 string 和 System.String，其实这两个是一个意思，编译器会把 string 映射到 System.String 上。

基元类型还可以被写为字面值，比如 `123.ToString()`，字面值会被视为基元类型的实例。

## 值类型和引用类型

---

## 什么是值类型、引用类型

值类型主要有结构和枚举（enum）两类，结构分为以下几种：

* 整型（sbyte、byte、char、short、ushort、int、uint、long、ulong）
* 浮点型（float、double）
* decimal
* bool
* 用户自定义结构（struct）

引用类型一般有 object、class、dynamic 三种。

### 二者的区别

**内存的分配方式：**

值类型存储在栈空间，在声明后要进行初始化才能够使用，不能够赋值为 null（除非使用 `?` 进行约束）。值类型在超出其作用域之后会自动释放内存。

引用类型本身存储在栈空间，但其指向的内存是堆上分匹配的。引用类型类似于 C++ 中的指针，不过 C# 对指针进行了封装，因此用起来会有些不同。引用类型的回收是通过 C# 的 GC 机制，你可以将引用类型赋值为 null，C# 会在适当的时机释放掉它的内存。

**参数传递方式：**

值传递会开辟一片新的内存，并将原本的值复制过来，相当于创建了一个临时对象。引用传递在传递时只是复制引用本身，它所指向的内存不变。

不过请注意，虽然原引用和传进来的引用都指向同一片内存，但是这两个引用本身是不同的。具体可以看下面的代码：

```csharp
public class Info
{
    public string str { get; set; }
}

public void ChangeString(Info info)
{
    info = new Info();
    info.str = "World";
}

public void PrintString()
{
    Info info = new Info();
    info.str = "Hello";
    ChangeString(info);
    Console.WriteLine(info.str);
}
```

调用 `PrintString` 打印的结果为 `Hello`，原因是引用传递其实是传递引用的副本，把这个副本指向新的内存是不会影响到原引用的。

如果我们再修改一下：

```csharp
public void ChangeString(ref Info info)
{
    info = new Info();
    info.str = "World";
}
```

打印的结果为 `World`，原因是 ref 关键字会把原本的引用传进来，相当于“引用的引用”，所以上述操作相当于更改了原引用指向的对象，因此打印结果发生了改变。

## 装箱与拆箱

---

### 什么是装箱/拆箱

所谓的装箱与拆箱指的是引用类型和值类型之间的转换。我们都知道，object 是所有数据类型的终极基类，可以被分配任何类型（值类型、引用类型、预定义类型、用户自定义类型）。不过在为其分配值之前，要进行类型转换。

装箱指的是值类型转换成引用类型：

```csharp
int val = 1;
object obj = val;
```

拆箱指的是将由值类型转换成的引用类型再转回到值类型：

```csharp
int val = 1;
object obj = val;       // 先装箱
int val2 = obj as int;  // 只有装过箱的数据才能够拆箱
```

### 为什么要有装箱

某些时候，我们需要接受任意类型的对象，以保证方法的通用性，因此这类方法会接收一个 object 类型参数。当你传入一个值类型（比如 Int32）时，C# 就会对其进行装箱。

### 装箱内部操作

装箱是在堆中生成一个对象实例，并把值类型的值赋值给该实例。具体为：

* 新分配托管堆内存（值类型大小+方法表指针+SyncBlockIndex）
* 将值类型的值拷贝到新分配的内存中
* 返回托管堆中新分配对象的地址，也就是该对象的引用

### 示例讲解

下面是一个简单的例子：

```csharp
Struct A : ICloneable 
{
    public Int32 x;
    public override String ToString()
    {
        return String.Format(”{0}”,x);
    }
    public object Clone()
    {
        return MemberwiseClone();
    }
    public void Change(Int32 x)
    {
        this.x = x;
    }
}
static void main()
{
    A a;
    a.x = 100;
    Console.WriteLine(a.ToString());
    Console.WriteLine(a.GetType());
    A a2 = (A)a.Clone();
    ICloneable c = a2; Ojbect o = c.Clone();
}
```

我们来分析一下这个程序在哪里进行了装箱和拆箱：

* a.ToString()：首先 A 是值类型，因此不会出现多态行为，直接调用该方法。该方法是对值类型的基类 `System.ValueType` 的重写。
* a.GetType()：`GetType` 也继承自 `System.ValueType`，调用它需要使用方法表指针，因此 a 被装箱以生成方法表指针。
* a.Clone()：该方法是对接口的实现，可以直接调用。
* 将 a 转成接口类型：这一步是把值类型转成引用类型，因此需要装箱。
* c.Clone()：接口类型调用方法，无需装箱。

上面提到的方法表指针有点类似于 C++ 的虚函数表，用于实现多态机制。由于值类型没有方法表指针，因此需要通过装箱来生成。

接着上面的代码，再来看一下新的例子：

```csharp
A a = new A();
a.x = 100;
Object o = a;
((A)o).Change(200);     // 这一步是否能够修改掉o.x的值？
```

上面的代码是先对值类型 a 进行装箱，然后再对引用类型 o 拆箱并调用 `Change()` 方法。由于拆箱时会生成一个临时的栈对象，因此改动只会作用于临时对象。如果想要对 o 进行改动，那么就不能够进行拆箱。由于 `Change()` 方法是对接口的实现，因此这里可以将 o 转成接口类型并调用方法：

```csharp
((IChange)o).Change(200);   // o继承自ICloneable，可以直接调用Change()
```

这样一来 o 就不会装箱，可以直接修改其值。

### 如何减少装箱/拆箱

在优化代码前，我们得先看看哪些情况下会发生装箱和拆箱：

* 首先是使用非泛型集合时，比如 ArrayList，这种集合没有泛型，所以数据都是以 Object 类型存储的。
* 当调用 Object 类型的非虚方法，由于值类型没有方法表指针，因此会进行装箱操作（比如上面提到的 GetType）。另外，当调用 Object 的虚方法时，如果值类型没有重写虚方法，那么也是需要装箱的。所以在自定义值类型时，要记得重写对应虚方法（比如 ToString）。
* 将值类型转成接口类型时也会进行装箱操作，这是因为接口类型也属于引用。

解决方法主要有两个：

* 尽量使用重载函数
* 使用泛型

在优化装箱/拆箱时，可以查看反编译的 IL 代码，这样就可以直观地寻找到多余的装拆箱操作。

### 如何选择类和结构体

在设计数据结构时，我们首选类，因为结构体是一种特殊的值类型，并且它不能够被派生。一般来说，只有当以下情况发生时才选择结构体：

* 类型具有基元类型的行为，也就是说类型很简单，没有成员会修改类型的任何字段。这些字段通常会被建议标记为 readonly
* 类型不会被派生，也不需要去继承
* 类型实例较小（小于 16 字节）
* 类型实例较大，但不适合作为方法参数传递，也不作为方法返回值