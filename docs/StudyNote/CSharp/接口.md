# 接口

C# 不支持多继承，我们可以用接口来做到这一点。

## 基本语法

---

接口基本规则如下：

* 接口不能被实例化
* 接口只能包含方法的声明
* 接口的成员包括方法、属性、索引器、事件
* 接口中不能够包含常量、字段、构造函数、析构函数、静态成员

我们可以通过接口来实现多重继承，但要注意接口的成员不能有 public、protected、private、internal 等关键字修饰。原因很简单，因为接口是要靠外部类去实现的，所以其修饰符默认为 public。

接口成员也不能够被 new、static、abstract、override、virtual 等关键字修饰。但如果用一个接口去继承另一个接口，且两个接口存在同名方法时，可以用 new 隐藏掉父接口的方法。

接口中不包含构造函数，因此无法实例化，并且接口只能包含方法、属性、事件、索引器。实现类必须实现所有接口方法，若实现类为抽象类，那么可以将接口方法声明为抽象方法，交由派生类实现。实现类在实现接口的方法时要将其声明为 public，除此之外也可以将其标记为 virtual。

下面是一个简单的示例：

```csharp
public interface IReusable
{
    void OnSpawn();

    void OnUnSpawn();
}

public class Test : IReusable
{
    // 实现接口方法时要将其标记为public
    public void OnSpawn()
    {

    }

    // 可以用虚函数形式实现接口方法
    public virtual void OnUnSpawn()
    {

    }
}
```

## 接口方法、抽象方法、虚方法

---

接口一般是用于规范，而抽象类则是用于共性。抽象类是一个类，因此只能是单继承，而接口则可以实现多个。接口中只能够声明方法、属性、事件、索引器，而抽象类则可以声明非静态的变量，并且可以实现普通的方法。

抽象类的抽象方法和接口的方法都没有具体的实现，必须通过子类来实现。二者的区别在于，抽象方法要用 override 来重写，而接口的方法则是直接实现。

虚方法则是多态的一部分，必须要有具体实现。如果子类重写了父类的方法，那么在调用派生类实例时，调用的就是子类的方法。

## 隐式实现接口与显示实现接口

---

隐式实现接口指的就是上面的代码所演示的，在实现接口方法时需要将其标记为 public，并且实现类和接口都可以调用该方法。

其实，接口方法还可以被**显示实现**：

```csharp
public interface IReusable
{
    void OnSpawn();

    void OnUnSpawn();
}

public class Test : IReusable
{
    // 显示实现接口不能够加访问权限，同时必须写上接口前缀
    void IReusable.OnSpawn()
    {

    }

    void IReusable.OnUnSpawn()
    {

    }
}
```

显示实现的接口方法只能够由接口进行调用，不能够通过实现类来调用：

```csharp
// 合法
IReusable reusable = new Test();
reusable.OnSpawn();

// 不合法
Test test = new Test();
test.OnSpawn();
```