# 资源加载框架

这一章的内容可能比较多，主要是总结一下我在平时的学习以及实习过程中积累下来的各类知识，然后把它们整合成一个简单的游戏框架。由于我目前正在用这个框架写毕设，源码的话得等我补充完毕后才会上传。

还是老样子，我只会介绍一下实现思路，具体的代码需要各位自行阅读。

?> 游戏框架的大小取决于项目的需求，并不是说一个框架就能够通吃所有游戏。

## 框架大纲

---

框架的基本功能大致如下，部分模块可能要之后才会补全：

* AssetBundle打包
* 资源加载
* 对象池管理
* UI管理
* 音效管理
* 特效管理
* 网络通信
...

## AssetBundle打包

---

一般的打包流程为：在编辑器中设置 AB 包名、生成 AB 包、根据 manifest 加载资源。这种做法的缺点很明显，需要开发者手动去设置包名，并且极易造成冗余。

打包脚本的流程为：通过脚本统一设置 AB 包名、处理冗余、生成自定义配置表、根据配置表加载资源。这种做法相比起上面那种，不仅大大减少了操作步骤，同时还能够解决冗余问题。

下面就来介绍一下打包脚本的各个环节是怎么实现的。

### 划分资源目录

在实际的项目开发过程中，美术通常会上传一大堆资源，这些资源有的会被用到，而有的则是压根就没有被用过。为了减小包体大小，我们需要明确哪些资源是游戏所必需的，也就是说需要动态加载的资源有哪些。

最容易想到的应该是 Prefab，其次就是 Sound、Shader、Texture 这类资源。材质、贴图等资源一般不会直接加载，通常是把它们挂载到 Model 上，然后把 Model 做成一个 Prefab 进行加载。

我的做法是把所有的 Prefab 单独进行打包，而诸如 Sound、Shader 等资源则是以文件夹为单位进行打包。如果 Prefab 太多的话，也可以文件夹形式进行打包。

?> 目录的划分仅供参考，请根据项目的实际需求进行修改。

### 设置包名并处理冗余

冗余的问题我在基础篇中讲过，对于没有被指定打包的外部资源，若存在多个 AB 包依赖它，打包时该资源就会被多次打包进依赖于它的 AB 包中，造成了资源冗余。说白了，要想解决这个问题，就必须要为所有的依赖项设置包名。

处理的步骤如下：

* 调用 `AssetDatabase.GetDependencies()` 获取依赖项
* 统一为这些依赖项设置包名
* 如果依赖项已存在于现有的包中，那么就不对其进行修改

这样一来，若多个包同时依赖于某个资源，那么该资源会被打进最早的包中，其它的包则只会引用最早的包。

### 生成配置表

Unity 在打包完毕后会自动生成资源配置表，不过为了方便开发者浏览所有的资源，最好还是自定义一个配置表。序列化方式有很多种，我这里采用的是 XML 和二进制，XML 用来阅读，二进制用于游戏加载。

配置表需要记录的信息可以参考 `.manifest` 文件，我这里给出一个范例：

* 资源文件相对于 Assets 目录的路径
* crc
* AB 包名
* 资源名称
* 依赖的 AB 包列表

打包脚本一共会经历两次过滤。第一次过滤是在设置包名的时候，目的是为了避免重复打包和重复设置包名。第二次过滤可选，目的是简化配置表，剔除掉不需要动态加载的资源。举个例子，材质、贴图等资源一般是不会直接加载的，它们通常跟随 Prefab 一起加载到游戏中，因此不必将它们写入到配置表中。

为了方便起见，我们可以实现把需要动态加载的资源的路径记录下来，在写入配置表时判断当前资源路径是否属于动态加载的资源路径，属于的话就将其写入。

关于路径的从属判断，我们不能够直接使用 `string.Contains()`，否则遇到下面这种情况时就会出错：

    路径A：Assets/Test
    路径B：Assets/TestTTT/a.prefab

显然，路径 B 并不属于路径 A，但是用 `Contains` 方法判断的结果为 `true`，理由是路径 A 和路径 B 都包含了相同的字符串。正确的做法应该是把路径 B 中与路径 A 相同的部分去除掉，如果路径 B 剩下的首字符为 `'/'`，那么路径 B 就属于路径 A。

```csharp
private static bool ContainsFileAB(string path)
{
    foreach (string abPath in allFileABList)
    {
        if (path == abPath || (path.Contains(abPath) && path.Replace(abPath, "")[0] == '/'))
        {
            return true;
        }
    }

    return false;
}
```

可以对比一下不过滤和过滤的差别：

![](http://cdn.fantasticmiao.cn/image/post/Unity/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/01.png)

![](http://cdn.fantasticmiao.cn/image/post/Unity/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/02.png)

## 资源加载

---

这一部分是整个框架的重中之重，也是最需要花时间去理解的。资源的加载方式可以分为同步和异步，而资源的种类也可分为不需要实例化的和需要实例化的。所谓的实例化资源，指的就是类似于 Prefab 的 GameObject 类型资源，需要调用 `GameObject.Instantiate()` 进行实例化。

### 同步加载

AssetBundle 提供了同步加载方式 `AssetBundle.LoadAsset()`，不过缺点是该方法只能够对 AB 包进行加载。我们在开发游戏时不可能每次运行前都进行打包，这样无疑会浪费很多时间。

我之前在基础篇中介绍过编辑器下的加载方式：

```csharp
#if UNITY_EDITOR
    UnityEditor.AssetDatabase.LoadAssetAtPath<T>(path);
#endif
```

这样一来，当游戏运行在编辑器下时会直接加载对应资源，而运行在真机平台时则会使用 AB 包进行加载。

!> 注意，引用 `UnityEditor` 时必须加上判断，否则在真机上运行游戏时会提示找不到 UnityEditor。

### 异步加载

比起同步加载，异步加载就要复杂一些。异步加载会开启一个协程，然后不断地从处理异步加载请求，而我们每次申请异步加载资源时，其实就是往请求队列中添加请求。

异步加载请求应该怎么设计呢？方法有很多种，下面我给出一个范例：

* 消息队列
* 资源路径
* 资源类型
* 加载优先级

首先说一下消息队列。这个消息队列主要是记录回调方法，因为异步加载并不是立即执行的，当有多个对象加载同一个资源时，就可以把所有的回调方法加入到消息队列中，等资源加载完毕后统一执行。

如果你没有接触过异步加载，你可能会对回调方法有些陌生。其实很好理解，异步加载需要一定的时间，我们并不知道资源什么时候能够加载完毕，所以只能够提供一个回调方法，让资源加载完毕之后自动执行。对比一下同步加载和异步加载的参数和返回值：

```csharp
public T LoadAsset<T>(string path)
{
    // 同步加载资源...

    return obj as T;
}

public void LoadAssetAsync<T>(string path, Callback callback)
{
    // 异步加载资源...

    // 调用回调方法
    callback(obj);
}
```

同步加载会返回对应的资源，可以直接对资源进行操作，而异步加载则是不行的。

接下来再说说其它三个参数。路径就不说了，加载优先级也很容易理解，我这里重点提一下资源类型。其实我之前写异步加载方法的时候并没有用泛型，因为那样写的话你就得把协程改成泛型，并且调用时机也要改，所以想了一会儿之后也就没当回事。不过后来当我对图片进行异步加载时，就发现了一个比较尴尬的问题：

```csharp
image.sprite = obj as T;
```

我本来想把 `UnityEngine.Object` 转成 `Sprite` 类型，结果一运行游戏发现图片没加载出来。查阅了一番资料后，我这才发现 Unity 在加载图片资源时，最终得到的格式为 `Texture2D`，而这个格式不能直接转换成 Sprite。如果你想直接得到 Sprite，那么你就必须调用泛型方法指定资源的格式。辛运的是，Unity 提供了根据 `Type` 加载指定资源的方法，如果协程不好更改的话，你可以记录下 Type 然后当作参数传入：

```csharp
AssetBundle.LoadAsset<T>(path);
AssetBundle.LoadAsset(path, type);
```

?> 资源加载方法最好写成泛型，避免出现类型无法转换的问题。

### 资源卸载

卸载这一块我也折腾了蛮久，主要是编辑器下卸载资源比较麻烦。基础篇中我讲了 AB 包的卸载，当调用 `Unload(true)` 时，会把 AB 包的内存镜像连同它加载出来的资源一起删掉。如果你调用的是 `Unload(false)`，那么被删的只有 AB 包，加载出来的资源则不会删掉。如果你想要清除这些游离的资源，那么可以使用 `Resources.UnloadUnusedAssets()`。

你以为会这么简单吗？当然不是，从这里开始就涉及到 Unity 各种坑了。我们先来看看 `UnloadUnusedAssets` 这个方法，翻译过来就是“清理未被使用的资源”，那么这里就有一个疑问，到底什么是未被使用的资源呢？或者说怎样才算是正在使用？

事实上，当你把资源赋值给一个引用对象时，该资源就处在使用状态了。这时候如果你调用 `UnloadUnusedAssets`，资源是不会被卸载掉的，因为还有对象在引用该资源。也就是说，如果我们想要用这个方法来卸载资源，就必须要把引用了该资源的对象手动置空。之前我就遇到过怎么卸载都不行的情况，后来一看才发现是协程中有个对象没置空，从而导致内存泄漏。

为了解决这个糟心的问题，我还是建议各位使用 `Unload(true)` 一次性把资源全部卸载掉，否则极有可能会导致内存的泄漏。频繁地调用 `UnloadUnusedAssets` 是不可取的，因为该方法是异步的，会搜索所有未被使用的资源，本身的效率并不高。

另外，`GameObject.Destroy()` 通常用于删除 GameObject 以及其挂载的各种组件，它引用的资源是无法删除的。`Resources.UnloadAsset()` 虽然可以卸载资源，但是它并不支持 GameObject、Component 以及 AssetBundle。

### 如何管理资源

虽然我建议各位使用 `Unload(true)`，但这又引发了另外一个问题。请各位想想看，假如有两个对象引用了同一个包中的资源，对象 A 申请了资源卸载，但对象 B 仍在使用该资源，按照正常的逻辑而言，我们不应该把资源卸载掉，否则就会出现缺失资源的情况。也就是说，我们得对资源加以管理，让它能够稳定地进行加载与卸载。

基础篇中我有提过，可以使用**引用计数**来管理资源。什么是引用计数呢？举个例子，假设资源 a 的初始计数为 0，当 a 被加载时，计数加一；当其他对象申请加载 a 时，由于它已经加载过了，所以不必重复加载，只需要对引用计数加一即可；当有对象申请卸载 a 时，计数减一；若某一时刻引用计数归零，代表该资源没有被任何对象使用，此时就可以把资源卸载掉了。

不过请注意，`Unload()` 方法其实是对 AB 包进行卸载，而一个包可能加载了多个资源，我们得保证包中的资源都处于未使用状态后才能够卸载 AB 包，否则还是会出现缺失资源的 BUG。因此，我们也需要给 AB 包加上引用计数。

说完了引用计数，再来说一说如何管理资源缓存。当一个资源的处于未使用状态时，我们可以对其进行销毁，但假如该资源是需要被频繁加载的类型，那么我们就最好不要直接将其卸载掉，否则重复地加载卸载将严重影响游戏的性能。不过总是把它放着也不是个事，毕竟资源越堆越多的话内存有点吃不消，我们得想个什么办法来自动清理资源。

我使用的方法比较简单。若资源的引用计数归零，假如不销毁该资源，那么就将其存进一个双向链表中。当游戏占用的内存过大时，我们就可以清理链表中的资源。为什么要使用双向链表呢？这是因为双向链表的插入和删除操作非常快，我们可以让双向链表中的资源以**最后使用时间**进行排序，清理资源时首先选择那些长久未使用的资源。

最后，当资源链表中的资源再次被使用时，别忘了把它从链表中删除。虽说就算不删掉也不会导致资源被意外回收（因为资源有引用计数），但毕竟链表中存的都是未被使用的资源，出于程序的逻辑性考虑，还是将其删掉为好。

?> 如果你想要做的更细致一点，可以编写一个类对象池来控制类的创建与销毁，减少 GC。