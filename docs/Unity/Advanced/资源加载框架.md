# 资源加载框架

这一章的内容可能比较多，主要是总结一下我在平时的学习以及实习过程中积累下来的各类知识，然后把它们整合成一个简单的游戏框架。由于我目前正在用这个框架写毕设，源码的话得等我补充完毕后才会上传。

还是老样子，我只会介绍一下实现思路，具体的代码需要各位自行阅读。

?> 游戏框架的大小取决于项目的需求，并不是说一个框架就能够通吃所有游戏。

## 框架大纲

---

框架的基本功能大致如下，部分模块可能要之后才会补全：

* AssetBundle打包
* 资源加载
* 对象池管理
* UI管理
* 音效管理
* 特效管理
* 网络通信
* ...

## AssetBundle打包

---

一般的打包流程为：在编辑器中设置 AB 包名、生成 AB 包、根据 manifest 加载资源。这种做法的缺点很明显，需要开发者手动去设置包名，并且极易造成冗余。

打包脚本的流程为：通过脚本统一设置 AB 包名、处理冗余、生成自定义配置表、根据配置表加载资源。这种做法相比起上面那种，不仅大大减少了操作步骤，同时还能够解决冗余问题。

下面就来介绍一下打包脚本的各个环节是怎么实现的。

### 划分资源目录

在实际的项目开发过程中，美术通常会上传一大堆资源，这些资源有的会被用到，而有的则是压根就没有被用过。为了减小包体大小，我们需要明确哪些资源是游戏所必需的，也就是说需要动态加载的资源有哪些。

最容易想到的应该是 Prefab，其次就是 Sound、Shader、Texture 这类资源。材质、贴图等资源一般不会直接加载，通常是把它们挂载到 Model 上，然后把 Model 做成一个 Prefab 进行加载。

我的做法是把所有的 Prefab 单独进行打包，而诸如 Sound、Shader 等资源则是以文件夹为单位进行打包。如果 Prefab 太多的话，也可以文件夹形式进行打包。

?> 目录的划分仅供参考，请根据项目的实际需求进行修改。

### 设置包名并处理冗余

冗余的问题我在基础篇中讲过，对于没有被指定打包的外部资源，若存在多个 AB 包依赖它，打包时该资源就会被多次打包进依赖于它的 AB 包中，造成了资源冗余。说白了，要想解决这个问题，就必须要为所有的依赖项设置包名。

处理的步骤如下：

* 调用 `AssetDatabase.GetDependencies()` 获取依赖项
* 统一为这些依赖项设置包名
* 如果依赖项已存在于现有的包中，那么就不对其进行修改

这样一来，若多个包同时依赖于某个资源，那么该资源会被打进最早的包中，其它的包则只会引用最早的包。

### 生成配置表

Unity 在打包完毕后会自动生成资源配置表，不过为了方便开发者浏览所有的资源，最好还是自定义一个配置表。序列化方式有很多种，我这里采用的是 XML 和二进制，XML 用来阅读，二进制用于游戏加载。

配置表需要记录的信息可以参考 `.manifest` 文件，我这里给出一个范例：

* 资源文件相对于 Assets 目录的路径
* crc
* AB 包名
* 资源名称
* 依赖的 AB 包列表

打包脚本一共会经历两次过滤。第一次过滤是在设置包名的时候，目的是为了避免重复打包和重复设置包名。第二次过滤可选，目的是简化配置表，剔除掉不需要动态加载的资源。举个例子，材质、贴图等资源一般是不会直接加载的，它们通常跟随 Prefab 一起加载到游戏中，因此不必将它们写入到配置表中。

为了方便起见，我们可以实现把需要动态加载的资源的路径记录下来，在写入配置表时判断当前资源路径是否属于动态加载的资源路径，属于的话就将其写入。

关于路径的从属判断，我们不能够直接使用 `string.Contains()`，否则遇到下面这种情况时就会出错：

    路径A：Assets/Test
    路径B：Assets/TestTTT/a.prefab

显然，路径 B 并不属于路径 A，但是用 `Contains` 方法判断的结果为 `true`，理由是路径 A 和路径 B 都包含了相同的字符串。正确的做法应该是把路径 B 中与路径 A 相同的部分去除掉，如果路径 B 剩下的首字符为 `'/'`，那么路径 B 就属于路径 A。

```csharp
private static bool ContainsFileAB(string path)
{
    foreach (string abPath in allFileABList)
    {
        if (path == abPath || (path.Contains(abPath) && path.Replace(abPath, "")[0] == '/'))
        {
            return true;
        }
    }

    return false;
}
```

可以对比一下不过滤和过滤的差别：

![](http://cdn.fantasticmiao.cn/image/post/Unity/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/01.png)

![](http://cdn.fantasticmiao.cn/image/post/Unity/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/02.png)

## 资源加载

---

这一部分是整个框架的重中之重，也是最需要花时间去理解的。资源的加载方式可以分为同步和异步，而资源的种类也可分为不需要实例化的和需要实例化的。所谓的实例化资源，指的就是类似于 Prefab 的 GameObject 类型资源，需要调用 `GameObject.Instantiate()` 进行实例化。

### 同步加载

AssetBundle 提供了同步加载方式 `AssetBundle.LoadAsset()`，不过缺点是该方法只能够对 AB 包进行加载。我们在开发游戏时不可能每次运行前都进行打包，这样无疑会浪费很多时间。

我之前在基础篇中介绍过编辑器下的加载方式：

```csharp
#if UNITY_EDITOR
    UnityEditor.AssetDatabase.LoadAssetAtPath<T>(path);
#endif
```

这样一来，当游戏运行在编辑器下时会直接加载对应资源，而运行在真机平台时则会使用 AB 包进行加载。

!> 注意，引用 `UnityEditor` 时必须加上判断，否则在真机上运行游戏时会提示找不到 UnityEditor。

### 异步加载

比起同步加载，异步加载就要复杂一些。异步加载会开启一个协程，然后不断地从处理异步加载请求，而我们每次申请异步加载资源时，其实就是往请求队列中添加请求。

异步加载请求应该怎么设计呢？方法有很多种，下面我给出一个范例：

* 消息队列
* 资源路径
* 资源类型
* 加载优先级

首先说一下消息队列。这个消息队列主要是记录回调方法，因为异步加载并不是立即执行的，当有多个对象加载同一个资源时，就可以把所有的回调方法加入到消息队列中，等资源加载完毕后统一执行。

如果你没有接触过异步加载，你可能会对回调方法有些陌生。其实很好理解，异步加载需要一定的时间，我们并不知道资源什么时候能够加载完毕，所以只能够提供一个回调方法，让资源加载完毕之后自动执行。对比一下同步加载和异步加载的参数和返回值：

```csharp
public T LoadAsset<T>(string path)
{
    // 同步加载资源...

    return obj as T;
}

public void LoadAssetAsync<T>(string path, Callback callback)
{
    // 异步加载资源...

    // 调用回调方法，对加载好的资源进行处理
    callback(obj);
}
```

同步加载会返回对应的资源，可以直接对资源进行操作，而异步加载则是不行的。

接下来再说说其它三个参数。路径就不说了，加载优先级也很容易理解，我这里重点提一下资源类型。其实我之前写异步加载方法的时候并没有用泛型，因为那样写的话你就得把协程改成泛型，并且调用时机也要改，所以想了一会儿之后也就没当回事。不过后来当我对图片进行异步加载时，就发现了一个比较尴尬的问题：

```csharp
image.sprite = obj as T;
```

我本来想把 `UnityEngine.Object` 转成 `Sprite` 类型，结果一运行游戏发现图片没加载出来。查阅了一番资料后，我这才发现 Unity 在加载图片资源时，最终得到的格式为 `Texture2D`，而这个格式不能直接转换成 Sprite。如果你想直接得到 Sprite，那么你就必须调用泛型方法指定资源的格式。辛运的是，Unity 提供了根据 `Type` 加载指定资源的方法，如果协程不好更改的话，你可以记录下 Type 然后当作参数传入：

```csharp
AssetBundle.LoadAsset<T>(path);
AssetBundle.LoadAsset(path, type);
```

上面两个方法效果是一样的。

?> 资源加载方法最好写成泛型，避免出现类型无法转换的问题。

### 资源卸载

卸载这一块我也折腾了蛮久，主要是编辑器下卸载资源比较麻烦。基础篇中我讲了 AB 包的卸载，当调用 `Unload(true)` 时，会把 AB 包的内存镜像连同它加载出来的资源一起删掉。如果你调用的是 `Unload(false)`，那么被删的只有 AB 包，加载出来的资源则不会删掉。如果你想要清除这些游离的资源，那么可以使用 `Resources.UnloadUnusedAssets()`。

你以为会这么简单吗？当然不是，从这里开始就涉及到 Unity 各种坑了。我们先来看看 `UnloadUnusedAssets` 这个方法，翻译过来就是“清理未被使用的资源”，那么这里就有一个疑问，到底什么是未被使用的资源呢？或者说怎样才算是正在使用？

事实上，当你把资源赋值给一个引用对象时，该资源就处在使用状态了。这时候如果你调用 `UnloadUnusedAssets`，资源是不会被卸载掉的，因为还有对象在引用该资源。也就是说，如果我们想要用这个方法来卸载资源，就必须要把引用了该资源的对象手动置空。之前我就遇到过怎么卸载都不行的情况，后来一看才发现是协程中有个对象没置空，从而导致内存泄漏。

为了解决这个糟心的问题，我还是建议各位使用 `Unload(true)` 一次性把资源全部卸载掉，否则极有可能会导致内存的泄漏。频繁地调用 `UnloadUnusedAssets` 是不可取的，因为该方法是异步的，会搜索所有未被使用的资源，本身的效率并不高。

另外，`GameObject.Destroy()` 通常用于删除 GameObject 以及其挂载的各种组件，它引用的资源是无法删除的。`Resources.UnloadAsset()` 虽然可以卸载资源，但是它并不支持 GameObject、Component 以及 AssetBundle。

?> `GameObject.Destroy()` 是在当前帧结束时才会销毁游戏对象，这点请记住。

### 如何管理资源

虽然我建议各位使用 `Unload(true)`，但这又引发了另外一个问题。请各位想想看，假如有两个对象引用了同一个包中的资源，对象 A 申请了资源卸载，但对象 B 仍在使用该资源，按照正常的逻辑而言，我们不应该把资源卸载掉，否则就会出现缺失资源的情况。也就是说，我们得对资源加以管理，让它能够稳定地进行加载与卸载。

基础篇中我有提过，可以使用**引用计数**来管理资源。什么是引用计数呢？举个例子，假设资源 a 的初始计数为 0，当 a 被加载时，计数加一；当其他对象申请加载 a 时，由于它已经加载过了，所以不必重复加载，只需要对引用计数加一即可；当有对象申请卸载 a 时，计数减一；若某一时刻引用计数归零，代表该资源没有被任何对象使用，此时就可以把资源卸载掉了。

不过请注意，一个包可能加载了多个资源，我们得保证包中的资源都处于未使用状态后才能够卸载 AB 包，否则还是会出现缺失资源的 BUG。因此，我们也需要给 AB 包加上引用计数。

说完了引用计数，再来说一说如何管理资源缓存。当一个资源的处于未使用状态时，我们可以对其进行销毁，但假如该资源是需要被频繁加载的类型，那么我们就最好不要直接将其卸载掉，否则重复地加载卸载将严重影响游戏的性能。不过总是把它放着也不是个事，毕竟资源越堆越多的话内存有点吃不消，我们得想个什么办法来自动清理资源。

我使用的方法比较简单。若资源的引用计数归零，假如不销毁该资源，那么就将其存进一个双向链表中。当游戏占用的内存过大时，我们就可以清理链表中的资源。为什么要使用双向链表呢？这是因为双向链表的插入和删除操作非常快，我们可以让双向链表中的资源以**最后使用时间**进行排序，清理资源时首先选择那些长久未使用的资源。

最后，当资源链表中的资源再次被使用时，别忘了把它从链表中删除。虽说就算不删掉也不会导致资源被意外回收（因为资源有引用计数），但毕竟链表中存的都是未被使用的资源，出于程序的逻辑性考虑，还是将其删掉为好。

?> 如果你想要做的更细致一点，可以编写一个类对象池来控制类的创建与销毁，减少 GC。

### 资源加载需要注意的问题

各位在使用上述的资源加载方式时，不要光顾着加载而忘了卸载！虽然因为框架上的设计，重复加载某个资源并不会导致资源被复制多份，但由于我们使用了引用计数进行管理，你每进行一次加载就会增加一次资源的引用，所以当对象不需要使用资源时一定要调用回收方法来减少引用计数！否则你就会看着资源的引用计数越来越多，严重影响资源模块的清理逻辑。

!> 原则上来说，一次加载就必须对应一次卸载，所以调用加载方法的时候要谨慎，资源不用了记得回收。

## 对象池管理

---

这一部分其实并不难，因为资源管理已经做好了，对象池管理就只需要控制 GameObject 的显示、隐藏、加载、销毁就好了。游戏对象的回收其实只是把对象隐藏起来而已，这样做主要是是为了减轻游戏的绘制压力，

### 游戏对象的加载

加载的步骤如下：

* 先从对象池里面拿对象，如果没有就继续。
* 加载对应的资源，实例化游戏物体。
* 将游戏物体加入到对象池。

这里要注意一下，同一个 Prefab 可能需要被实例化成多个游戏物体，因此对象池在存的时候也要存多个游戏物体。

另外，我们每次从对象池拿对象时，其实都相当于对资源的一次引用。不过呢，由于直接从对象池取对象没有经历资源加载这一步，所以是不会改变资源引用计数的。我们需要在资源管理模块中编写一个对外的方法，专门供对象池改变资源的引用计数。

### 游戏对象的回收

回收的步骤如下：

* 判断游戏对象是否属于对象池，属于则继续。
* 判断该对象是否已经被回收，没有则继续。
* 判断对象池是否已经超出最大容量，没有则回收，有则直接销毁。

由于同一种 Prefab 会有多个实例对象，为了管理对象池的容纳上限，我们可以在卸载资源时传入某个对象的最大可容纳上限，当超过这个值时，后续回收的 GameObject 将被直接销毁。

?> 别忘了在回收时减少资源的引用计数

### 使用对象池的好处

这部分内容其实不算多，代码我都有注释，应该是能够轻松看懂的。我这里就主要来说一说使用对象池的好处吧。以射击游戏举例，游戏场景中重复出现的物体通常为敌人和子弹，如果我们不对其进行管理，那么频繁的创建和销毁将大大地影响游戏性能。我之前实习的时候做过弹幕射击游戏的 Demo，当里面的子弹数量达到成百上千发时，游戏的帧数就会降到一个非常低的数值。因此，对象池几乎是我们做游戏时必须要弄的一个东西，否则大量的 GC 操作将会让你的游戏不堪重负。

其实回想起当时 Demo 写的代码，我真觉得自己挺傻的，明明子弹只需要做成一个 Prefab，不同的子弹直接更换图片就好，我还傻乎乎的给把每个子弹都弄成了 Prefab。所以说，只有不断地学习，多阅读别人的代码才能够成长，否则写出来的代码永远都是那么难看。