# 图形渲染基础

游戏的渲染可以简单地理解成将模型的一个个顶点经过层层处理并最终转化到屏幕上的过程。

## 渲染流水线概览

---

### 概念上的三个阶段

所谓的概念上的阶段，其实是按照渲染流程的功能进行划分的，而真正意义上的渲染流水线其实是 GPU 流水线。

渲染流水线从概念上分为：

* 应用阶段：CPU 执行，负责输出渲染所需要的渲染图元（点、线、三角面）。
* 几何阶段：GPU 执行，根据渲染图元绘制几何相关图元。
* 光栅化阶段：GPU 执行，决定每个渲染图元的哪些像素绘制到屏幕上。

### 应用阶段

应用阶段是由我们的应用所主导的，通常由 CPU 负责实现。说白了，开发者对于这个阶段有绝对的控制权。

应用阶段主要有三个任务：首先，我们要准备好场景数据，比如摄像机的位置、视锥体、模型、光源等等；其次，为了提高渲染性能，我们需要进行粗粒度剔除（culling），将看不见的物体剔除掉；最后，我们要设置每个模型的渲染状态，比如它的材质、纹理、Shader 等等。这一阶段最重要的就是输出渲染图元，也就是提供几何阶段所需要的点、线、三角面等。

### 几何阶段

几何阶段负责处理每个渲染图元，由 GPU 负责执行。它会决定需要绘制的图元是什么，怎么绘制，以及在哪里绘制。几何阶段最重要的就是把顶点坐标转换成屏幕空间的二维顶点坐标，然后把这些顶点坐标、顶点对应的深度值、着色等信息传给下一个阶段。

### 光栅化阶段

光栅化阶段负责使用上一阶段的数据，并将它们生成为屏幕上的像素，由 GPU 负责执行。

## GPU 与 CPU 的交互

---

上面只是简单地介绍了一下渲染流水线的概念，接下来就对每个阶段进行仔细地讲解。

渲染流水线的起点是 CPU，也就是应用阶段，它主要有这么几个职责：

* 将数据加载到显存
* 设置渲染状态
* 调用 DrawCall

### 将数据加载到显存

渲染所需的数据都得先从硬盘中加载到内存，然后网格、纹理等数据又会从内存中复制到显存。之所以要这么做是因为显卡对于显存的访问速度更快，且一般的显卡无法直接访问内存。

一般来说，当数据被移动到显存之后，内存里的数据就可以丢弃了。如果你还想要访问某些数据（比如用网格来做碰撞检测），那么就需要将其保留下来。

### 设置渲染状态

简单点来说，CPU 需要指导 GPU 如何渲染一个网格，比如使用哪个着色器、光源、纹理、材质等。如果不修改渲染状态，那么所有网格都会用同一种渲染状态。

在设置完渲染状态后，就可以通知 GPU 开始渲染了，这个通知命令就是 DrawCall。

### 调用DrawCall

如果你有接触过渲染优化，那么你应该会听说过 DrawCall。事实上，DrawCall 是一个命令，由 CPU 发起，接收方是 GPU。这个命令会指向一个需要被渲染的图元，通知 GPU 对其渲染。

当发起 DrawCall 时，GPU 会根据预设的渲染状态和相关顶点数据进行计算，最终生成像素。

## GPU 流水线

---

GPU 流水线指的就是 GPU 的渲染过程，开发者对于几何阶段和光栅化阶段没有绝对控制权。当然，GPU 也提供了一些配置接口，可以让开发者进行优先的配置和编程。

GPU 相比于 CPU，它的功能较为单一，因此处理速度要比 CPU 快很多。

### 几何阶段细分

几何阶段可以细分为以下几个阶段：

* 顶点着色器：可编程，用于实现顶点的空间变换、逐顶点光照，将顶点坐标从模型空间转化到齐次剪裁空间，最终得到归一化的设备坐标。
* 曲面细分着色器：可选，用于细分图元。
* 几何着色器：可选，用于逐图元的着色、产生图元。
* 裁剪：可配置，将不在屏幕内的顶点剪裁掉，并剔除某些三角图元的面片。
* 屏幕映射：可配置和编程，将每个图元的坐标转换到屏幕坐标系。

### 顶点着色器的功能

几何阶段中比较重要的是顶点着色器，它处理的单位是顶点，每一个输入进来的顶点数据都会调用一次顶点着色器。顶点着色器不能够创建或销毁顶点，也不能得到顶点与顶点之间的关系。这种单一的功能使得 GPU 的处理效率变高。

顶点着色器最主要的工作就是把顶点坐标从模型空间转换到齐次裁剪空间，然后计算顶点的颜色。所谓的模型空间，就是指模型的建模空间。每个模型都会有独立的坐标系，一般由美术人员决定的。转换到齐次裁剪空间一般分为三步，首先是从模型空间转换到世界空间，然后再转换到观察空间（摄像机空间），最后转到齐次裁剪空间。

你经常能够在顶点着色器中见到如下代码，这种代码主要是把模型空间坐标转换成裁剪空间坐标：

```
o.vertex = mul(UNITY_MVP, v.vertex);    // 5.x
o.vertex = UnityObjectToClipPos(v.vertex);  // 2017以上版本
```

?> 顶点坐标转换、裁剪等步骤的原理会在之后的笔记中提到，这里不做展开。

### 光栅化阶段细分

光栅化阶段可以细分为以下几个阶段：

* 三角形设置：根据上一阶段传过来的顶点数据，计算出三角网格的边界像素坐标。
* 三角形遍历：检查每个像素是否被三角网格覆盖，如果被覆盖，则会产生一个片元（包含屏幕坐标、深度信息、顶点信息、法线、纹理坐标等）。
* 片元着色器（像素着色器）：可编程，对顶点着色器输出的顶点数据进行插值，输出片元的颜色值。
* 逐片元操作（输出合并阶段）：可配置，决定每个片元的可见性（模板测试、深度测试），然后将通过测试的片元颜色值和已在颜色缓冲区中的颜色进行合并（混合）。

### 什么是三角形设置

几何阶段输出的都是每一个顶点的数据，而我们最终是需要把顶点连接起来组成一个个三角网格。三角形设置就是将三个顶点连接起来得到三条边，然后计算每条边上的像素坐标，从而得到三角形网格的边界。这样一来，我们就可以把顶点转换成三角形来表示。

### 三角形遍历

三角形遍历阶段会检查每一个像素是否被一个三角网格所覆盖。如果像素被覆盖，那么就会产生出一个**片元**。这种寻找出哪些像素被三角网格覆盖的过程叫做三角形遍历。

三角形设置阶段用于生成三角形，而这一阶段则是用来判断一个三角形网格覆盖了哪些像素。被覆盖的像素将会根据三角网格顶点的数据进行**插值**，最终得到片元。

可能有人会问，为什么要进行插值？这是因为顶点着色器传递过来的只有顶点信息，而每一个片元的信息则是通过对顶点信息插值得到的。比如下面就是对于深度进行插值：

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/%E4%B8%89%E8%A7%92%E5%BD%A2%E9%81%8D%E5%8E%86.png)

我们可以简单地认为，一个模型包含的顶点越多，它经过插值得到的表现效果将更细腻，同时消耗的性能也更多。

该阶段完成将会产生大量的片元序列。每一个片元中包含的信息是很多的，比如深度、屏幕坐标、颜色等等。这些片元将被传递给片元着色器做进一步处理。

?> 片元不等同于像素。片元包含许多信息，而像素则是最终显示到屏幕上的。

### 片元着色器是干什么的

片元着色器的输入是上一个阶段对顶点信息插值得到的结果，具体的来说就是根据从顶点着色器中输出的数据插值得到的。片元着色器的输出是一个或多个颜色值。

片元着色器可以用来做许多重要的渲染，比如**纹理采样**。如果需要进行纹理采样，那么就必须要在顶点着色器阶段输出每个顶点所对应的纹理坐标，然后对顶点的纹理坐标进行插值得到每个片元的纹理坐标。下面是纹理采样的示意图：

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8.png)

### 逐片元操作

逐片元操作主要是决定每个片元的可见性，然后将通过了测试的片元与颜色缓冲区中的片元进行合并（混合）。

这里解释一下模板测试和深度测试。帧缓冲区有很多区构成，比如：

* 颜色缓冲区：用于绘图，包含每个像素的颜色。
* 深度缓冲区：用于深度测试，存储每个像素的深度值。当启动深度测试时，会将片元的深度值和深度缓冲区中的值进行比较，通过后会更新缓冲区中的值。
* 模板缓冲区：用于模板测试，存储模板值。它会将片元的值和参考值作比较，通过了则更新缓冲区。

其实这些缓冲区都是一样的，都是为了决定用哪个片元而已，区别只是存的值不同。以深度测试为例，它会将当前片元的深度值与缓冲区中已存在的深度值进行比较，如果当前片元的深度值较大，那么直接舍弃掉，否则就用这个片元的深度值覆盖掉原有的值（也可以选择不覆盖）。简单点来说，就是我们总是希望渲染离摄像机最近的物体，而那些离得远并且被其他物体挡住的就不需要渲染了。

模板测试和深度测试也差不多，GPU 首先会从模板缓冲区中读取该片元位置的模板值，然后把它与参考值进行比对。比较函数可以由开发者指定，没有通过测试的片元将会被丢弃。注意，即使片元没有通过模板测试，我们都可以根据模板测试以及之后的深度测试结果来修改模板缓冲区，这个操作也是由开发者指定的。模板测试通常用于限制渲染区域，渲染阴影，轮廓渲染等。

如果一个片元有幸通过了所有测试，那么它还需要执行混合操作。上面也讲了，所有像素的颜色都存在颜色缓冲区中，而通过测试的片元需要将自己的颜色存放到颜色缓冲区中。但问题是，如果颜色缓冲区的对应位置已经存在了颜色，这时候是直接将已有的颜色覆盖掉，还是进行其他的处理呢？

对于不透明的物体，可以关闭混合，直接将缓冲区中的颜色覆盖。而对于透明物体，就需要让新的颜色与已有的颜色进行混合，从而达到透明的效果。

测试的顺序并不是唯一的，并且开发者也可以关闭测试。如果想要提高 GPU 性能，需要尽可能的在片元着色器之前进行测试。举个很简单的例子，如果 GPU 费了很大力气计算出了片元的颜色，但是这个片元是不可见的，那么相当于这些计算就白做了。但如果某些测试必须要在片元着色器之后进行，那就只能够多消耗一些时间。

?> 模板测试和深度测试的具体过程可以自行查阅资料，这里不再展开。

## 其他问题

---

### 什么是DrawCall

我们在渲染优化时经常提到要减少 DrawCall，而所谓的 DrawCall 就是指 CPU 调用底层图形编程接口（比如 OpenGL 或者 DirectX），通知 GPU 进行渲染。在 Unity 中，每次引擎准备数据并通知 GPU 的过程就叫做一次 DrawCall，这个过程是逐物体进行的。

常见的一个误区就是认为 DrawCall 中造成性能问题的是 GPU，认为 GPU 上的状态切换很耗时。然而这时不正确的，真正的问题其实出在 CPU 上。

要解释这个问题，首先就得了解 CPU 和 GPU 是怎么并行工作的。CPU 和 GPU 之间会有一个**命令缓冲区**，CPU 通过图形编程接口向命令队列中添加命令，而 GPU 则会从中读取命令来执行。添加和读取的过程是相互独立的。

命令缓冲区中不光是存 DrawCall，其他命令还有改变渲染状态（比较耗时）、改变纹理、改变着色器等等。

### 为什么DrawCall多了会影响效率

举个很简单的例子，你可以尝试复制 10000 个 1kb 的文件，然后再去复制 1 个 10mb 的文件。显然，只复制一个文件要快得多。为什么会这样呢？这其实是因为复制一次文件需要很多额外的操作，比如分配内存什么的。如果操作过多，那么就会产生额外的性能开销。

渲染的过程虽然和复制文件不同，但其实也可以用上述的例子进行解释。我们在每次调用 DrawCall 前，CPU 需要先向 GPU 发送很多内容，比如数据、状态、命令等。在这个过程中，CPU 会进行很多工作，比如检查渲染状态等等。一旦 CPU 完成了这些工作，就可以调用 DrawCall 通知 GPU 进行渲染。由于 GPU 的工作相对单一，其本身的性能也非常强大，因此 GPU 的渲染速度往往快于 CPU 提交命令的速度。如果 DrawCall 太多，CPU 就会把大量时间花在提交 DrawCall 上，导致性能低下。

### 如何减少DrawCall

做法有很多种，这里介绍一下**批处理**。上面的例子中已经说明了提交大量的 DrawCall 会导致 CPU 性能问题，那么我们可以尝试将多个小的 DrawCall 合并成一个大的 DrawCall。

由于我们需要在 CPU 中合并网格，而合并过程也是需要时间的，因此批处理更适合用于那些静态物体，只需要合并一次即可。当然，我们也可以对动态物体进行合并，只不过由于动态物体每帧都在运动，所以我们每一帧都需要重新进行合并，会对性能造成一定影响。

在提升渲染性能时需要注意以下几点：

* 避免使用大量小网格，如果一定要用，那么考虑对其进行合并。要注意的是，批处理会将多个网格合并成一个大网格，并在一个 DrawCall 中渲染它们，也就是说这些网格会使用同一种渲染状态。如果网格之间需要使用不同的状态，那么就不能用批处理。
* 避免使用大量材质，且尽量在不同网格之间使用同一种材质。
* 切换材质和 Shader 也是非常耗时的操作。

### 什么是固定管线渲染

固定管线是指在比较旧的 GPU 上实现的渲染流水线。这种流水线只能提供一些配置操作，开发者无法控制对渲染的阶段进行控制。

现代 GPU 通常会具有更高的灵活性和可控性，所以渲染管线也变成了可编程的。如果不是为了兼容旧设备，那么建议使用可编程渲染管线。

### 什么是Shader

Shader 的中文翻译是着色器，主要用于告诉图形硬件如何计算和输出图像。这篇笔记主要讲述的是 GPU 的渲染流水线，而 Shader 则是渲染流水线的一部分。说得更具体一点，Shader 就是：

* GPU 流水线上一些可高度编程的阶段，由着色器编译出来的代码会在 GPU 上运行。
* 有一些特定类型的着色器，比如顶点着色器、片元着色器等。
* 依靠着色器可以控制流水线中的渲染细节，比如用顶点着色器来控制顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。