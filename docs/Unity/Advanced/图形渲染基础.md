# 图形渲染基础

## 渲染流水线概览

---

### 概念上的三个阶段

所谓的概念上的阶段，其实是按照渲染流程的功能进行划分的，而真正意义上的渲染流水线其实是 GPU 流水线。

渲染流水线从概念上分为：

* 应用阶段：CPU 执行，负责输出渲染所需要的渲染图元（点、线、三角面）。
* 几何阶段：GPU 执行，根据渲染图元绘制几何相关图元。
* 光栅化阶段：GPU 执行，决定每个渲染图元的哪些像素绘制到屏幕上。

### 应用阶段

应用阶段是由我们的应用所主导的，通常由 CPU 负责实现。说白了，开发者对于这个阶段有绝对的控制权。

应用阶段主要有三个任务：首先，我们要准备好场景数据，比如摄像机的位置、视椎体、模型、光源等等；其次，为了提高渲染性能，我们需要进行粗粒度剔除（culling），将看不见的物体剔除掉；最后，我们要设置每个模型的渲染状态，比如它的材质、纹理、Shader 等等。这一阶段最重要的就是输出渲染图元，也就是提供几何阶段所需要的点、线、三角面等。

### 几何阶段

几何阶段负责处理每个渲染图元，由 GPU 负责执行。它会决定需要绘制的图元是什么，怎么绘制，以及在哪里绘制。几何阶段最重要的就是把顶点坐标转换成屏幕空间的二维顶点坐标，然后把这些顶点坐标、顶点对应的深度值、着色等信息传给下一个阶段。

### 光栅化阶段

光栅化阶段负责使用上一阶段的数据，并将它们生成为屏幕上的像素，由 GPU 负责执行。

## GPU 与 CPU 的交互

---

上面只是简单地介绍了一下渲染流水线的概念，接下来就对每个阶段进行仔细地讲解。

渲染流水线的起点是 CPU，也就是应用阶段，它主要有这么几个职责：

* 将数据加载到显存
* 设置渲染状态
* 调用 DrawCall

### 将数据加载到显存

渲染所需的数据都得先从硬盘中加载到内存，然后网格、纹理等数据又会从内存中复制到显存。之所以要这么做是因为显卡对于显存的访问速度更快，且一般的显卡无法直接访问内存。

一般来说，当数据被移动到显存之后，内存里的数据就可以丢弃了。如果你还想要访问某些数据（比如用网格来做碰撞检测），那么就需要将其保留下来。

### 设置渲染状态

简单点来说，CPU 需要指导 GPU 如何渲染一个网格，比如使用哪个着色器、光源、纹理、材质等。如果不修改渲染状态，那么所有网格都会用同一种渲染状态。

在设置完渲染状态后，就可以通知 GPU 开始渲染了，这个通知命令就是 DrawCall。

### 调用DrawCall

如果你有接触过渲染优化，那么你应该会听说过 DrawCall。事实上，DrawCall 是一个命令，由 CPU 发起，接收方是 GPU。这个命令会指向一个需要被渲染的图元，但不会再包含其他的材质信息（因为之前的工作已经把数据发给 GPU 了）。

当发起 DrawCall 时，GPU 会根据预设的渲染状态和相关顶点数据进行计算，最终生成像素。

## GPU 流水线

---

GPU 流水线指的就是 GPU 的渲染过程，开发者对于几何阶段和光栅化阶段没有绝对控制权。当然，GPU 也提供了一些配置接口，可以让开发者进行优先的配置和编程。

### 几何阶段细分

几何阶段可以细分为以下几个阶段：

* 顶点着色器：可编程，用于实现顶点的空间变换、逐顶点光照，将顶点坐标从模型空间转化到齐次剪裁空间，最终得到归一化的设备坐标。
* 曲面细分着色器：可选，用于细分图元。
* 几何着色器：可选，用于逐图元的着色、产生图元。
* 裁剪：可配置，将不在屏幕内的顶点剪裁掉，并剔除某些三角图元的面片。
* 屏幕映射：可配置和编程，将每个图元的坐标转换到屏幕坐标系。

### 光栅化阶段细分

光栅化阶段可以细分为以下几个阶段：

* 三角形设置：根据上一阶段传过来的顶点数据，计算出三角网格的边界像素坐标。
* 三角形遍历：检查每个像素是否被三角网格覆盖，如果被覆盖，则会产生一个片元（包含屏幕坐标、深度信息、顶点信息、法线、纹理坐标等）。
* 片元着色器（像素着色器）：可编程，对顶点着色器输出的顶点数据进行插值，输出片元的颜色值。
* 逐片元操作（输出合并阶段）：可配置，决定每个片元的可见性（模板测试、深度测试），然后将通过测试的片元颜色值和已在颜色缓冲区中的颜色进行合并（混合）。

这里解释一下模板测试和深度测试。帧缓冲区有很多区构成，比如：

* 颜色缓冲区：用于绘图，包含每个像素的颜色。
* 深度缓冲区：用于深度测试，存储每个像素的深度值。当启动深度测试时，会将片元的深度值和深度缓冲区中的值进行比较，通过后会更新缓冲区中的值。
* 模板缓冲区：用于模板测试，存储模板值。它会将片元的值和参考值作比较，通过了则更新缓冲区。

其实这些缓冲区都是一样的，都是为了决定用哪个片元的像素而已，区别只是存的值不同。以深度测试为例，它会将当前片元的深度值与缓冲区中已存在的深度值进行比较，如果当前片元的深度值较大，那么直接舍弃掉，否则就用这个片元的深度值覆盖掉原有的值。简单点来说，就是我们总是希望渲染离摄像机最近的物体，而那些离得远并且被其他物体挡住的就不需要渲染了。所谓的测试主要就是决定那些物体可以被渲染。

另外，通过模板测试和深度测试的片元需要执行混合操作，混合操作会对颜色进行合并。上面也讲了，所有像素的颜色都存在颜色缓冲区中，而通过测试的片元需要将自己的颜色存放到颜色缓冲区中。这时候是直接将已有的颜色覆盖掉，还是进行其他的处理呢？

对于不透明的物体，可以关闭混合，直接将缓冲区中的颜色覆盖。而对于透明物体，就需要让新的颜色与已有的颜色进行混合，从而达到透明的效果。

测试的顺序并不是唯一的，并且开发者也可以关闭测试。如果想要提高 GPU 性能，需要尽可能的在片元着色器之前进行测试。举个很简单的例子，如果 GPU 费了很大力气计算出了片元的颜色，但是这个片元是不可见的，那么相当于这些计算就白做了。但如果某些测试必须要在片元着色器之后进行，那就只能够多消耗一些时间。

## 其他问题

---

### 什么是DrawCall

我们在渲染优化时经常提到要减少 DrawCall，而所谓的 DrawCall 就是指 CPU 调用底层图形编程接口（比如 OpenGL 或者 DirectX），通知 GPU 进行渲染。

常见的一个误区就是认为 DrawCall 中造成性能问题的是 GPU，认为 GPU 上的状态切换很耗时。然而这时不正确的，真正的问题其实出在 CPU 上。

要解释这个问题，首先就得了解 CPU 和 GPU 是怎么并行工作的。CPU 和 GPU 之间会有一个**命令缓冲区**，CPU 通过图形编程接口向命令队列中添加命令，而 GPU 则会从中读取命令来执行。添加和读取的过程是相互独立的。

命令缓冲区中不光是存 DrawCall，其他命令还有改变渲染状态（比较耗时）、改变纹理、改变着色器等等。

### 为什么DrawCall多了会影响效率

举个很简单的例子，你可以尝试复制 10000 个 1kb 的文件，然后再去复制 1 个 10mb 的文件。显然，只复制一个文件要快得多。为什么会这样呢？这其实是因为复制一次文件需要很多额外的操作，比如分配内存什么的。如果操作过多，那么就会产生额外的性能开销。

渲染的过程虽然和复制文件不同，但其实也可以用上述的例子进行解释。我们在每次调用 DrawCall 前，CPU 需要先向 GPU 发送很多内容，比如数据、状态、命令等。在这个过程中，CPU 会进行很多工作，比如检查渲染状态等等。一旦 CPU 完成了这些工作，就可以调用 DrawCall 通知 GPU 进行渲染。由于 GPU 的工作相对单一，其本身的性能也非常强大，因此 GPU 的渲染速度往往快于 CPU 提交命令的速度。如果 DrawCall 太多，CPU 就会把大量时间花在提交 DrawCall 上，导致性能低下。

### 如何减少DrawCall

做法有很多种，这里介绍一下**批处理**。上面的例子中已经说明了提交大量的 DrawCall 会导致 CPU 性能问题，那么我们可以尝试将多个小的 DrawCall 合并成一个大的 DrawCall。

由于我们需要在 CPU 中合并网格，而合并过程也是需要时间的，因此批处理更适合用于那些静态物体，只需要合并一次即可。当然，我们也可以对动态物体进行合并，只不过由于动态物体每帧都在运动，所以我们每一帧都需要重新进行合并，会对性能造成一定影响。

减少 DrawCall 需要注意以下几点：

* 避免使用大量小网格，如果一定要用，那么考虑对其进行合并。要注意的是，批处理会将多个网格合并成一个大网格，并在一个 DrawCall 中渲染它们，也就是说这些网格会使用同一种渲染状态。如果网格之间需要使用不同的状态，那么就不能用批处理。
* 避免使用大量材质。尽量在不同网格之间使用同一种材质。

### 什么是固定管线渲染

固定管线是指在比较旧的 GPU 上实现的渲染流水线。这种流水线只能提供一些配置操作，开发者无法控制对渲染的阶段进行控制。

现代 GPU 通常会具有更高的灵活性和可控性，所以渲染管线也变成了可编程的。如果不是为了兼容旧设备，那么建议使用可编程渲染管线。

### 什么是Shader

这篇笔记主要讲述的是 GPU 的渲染流水线，而 Shader 则是渲染流水线的一部分。说得更具体一点，Shader 就是：

* GPU 流水线上一些可高度编程的阶段，由着色器编译出来的代码会在 GPU 上运行。
* 有一些特定类型的着色器，比如顶点着色器、片元着色器等。
* 依靠着色器可以控制流水线中的渲染细节，比如用顶点着色器来控制顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。