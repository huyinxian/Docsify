# 商业常用UI框架概览

之前我查阅过网络上的资料，发现 UI 框架的内容比较少，或者是本身过于简单，很难帮助到那些想要进一步学习的初学者们。因此，这一章我将介绍几款我在公司中接触过的 UI 框架，以期望给各位提供一个框架实现思路。

除了常用的框架，我还会介绍一些项目中开发中可能遇到的一些问题。当然，由于我本身也只是一个才实习几个月的新人，因此这篇笔记只会点到为止，待我毕业正式入职之后会给各位带来更详尽的解决方案。

?> 本篇笔记介绍的三款框架都是公司里面的，所以我没法直接发源码。之后我会出几篇学习笔记，尽可能详细地给各位讲解框架的实现原理。

## UI框架的基本要求

---

一般来说，新人入职的首要工作就是要了解公司的 UI 框架，然后制作各种界面模块，在工作中逐步熟悉整个游戏项目。我本人在毕业前也实习了几个月，工作的主要内容就是负责项目的各类界面开发，因而也接触过几款 UI 框架，了解到了一些框架的共同点。

那么一个良好的 UI 框架应该是怎么样的呢？我这里列举一些个人的观点：

* UI 层级划分明确，对于窗体的管理要十分严谨
* 支持语言国际化
* 具备常用的 UI 控件
* ...

这里我只列举了部分要求，因为 UI 框架的体量是根据项目的需求来的，并不是说一个框架可以吃遍所有类型的项目。

## 三种商业框架概览

---

下面我将会介绍三款我在公司中接触过的框架，它们各有各的特色。至于哪种框架的设计比较好，这个就仁者见仁智者见智吧。

### 树状UI管理框架

这是我接触到的第一款 UI 框架，它将一个 UI 界面分为了森林、树、叶子三个层级。森林节点可以是一个大的界面，比如大厅界面。我们都知道，一个游戏的大厅界面通常会有许多 UI 元素，比如角色、背包、商场、活动、礼包等等，每点击一个按钮又会弹出新的子界面。如果把大厅界面视作是一片森林，那么这一个个子界面就可以看做是森林中的一颗颗独立的树，所有的树节点都由森林节点进行管理。

说完了森林，我们再缩小一下视野，聊一聊树节点。以背包界面为例，背包中会显示玩家所拥有的道具，而这些道具的图标又各不相同。为了能够让对应的格子显示对应的图标，我们可以把这些格子视作是树上的一片片叶子，所有的叶子节点由树节点统一进行管理。看到这里，想必你应该清楚了，这其实就是让较大的界面管理其下所有的子控件，然后由更大的界面去管理那些子界面。这种层层递进的方式形成了一颗 UI 树，每一个子节点都是由其父节点进行管理，相互之间的通信也可以经由父节点进行事件广播。

由于这款框架我用的不是很多，这里我就不对其进行详细评价了，因为我个人觉得这种管理方式略显繁琐，维护起来并不是很方便。

### 基于PureMVC的UI框架

这款框架我用的比较多，由于游戏项目是用 Lua 写的，因此框架本身提供了一些 Lua 接口。正如标题中所言，该 UI 框架基于 PureMVC，因此它不必如上一款框架那般自行维护一颗 UI 树，其结构的复杂度是有所降低的。如果你有看过我的 PureMVC 笔记，你应该就会知道视图的对外交互是通过中介者来执行的，反应到游戏中就是一个界面对应一个 Mediator，视图只负责操作视图组件，而 Mediator 则负责监听事件、发送事件。

可能有很多人对于 Lua 如何与 UI 控件进行交互不太理解，这里我解释一下。如果我们想要在代码里面操作 UI 控件，通常的做法是在代码中暴露一个公共字段，Unity 会将这个字段序列化，开发者只需在编辑器中手动拖拽进行赋值即可。遗憾的是，这种做法是不太合适的，因为手动的操作无疑会增大开发者的工作量以及 BUG 出现率，最好的解决方法应该是使用代码进行批量获取，也就是 `GetComponent()`。当然，通过纯手写来获取组件也是不对的，像这类重复性的劳动理应交由脚本来完成。

举个例子，我们可以写一个编辑器扩展脚本，它的功能是获取 UI 界面中所有可能用到的 UI 控件。我们公司的做法是将那些可能使用到的节点用 `m_` 的前缀进行标识，搜索时会将这些节点上的 UI 控件全部用代码获取下来（获取哪些控件要根据你用的是 UGUI 还是 NGUI 来决定），同时生成一个代码文件。使用时只需要在这个界面对应的视图代码中引用该文件，即可实现对 UI 控件的操作。总之一个原则，能够用脚本自动处理的操作不要手动去做，况且 Lua 文件无法像 C# 文件那样进行手动拖拽赋值，我们只能够使用代码获取 UI 控件。

说完了优点，我再来说说缺点。虽然这款 UI 框架的结构十分明了，但其层级结构却过于简单，一个界面就是一个 Canvas，并且整个界面的代码都放到了一个文件中，导致代码过长，后期维护起来不是很方便。

### 基于反射的UIBinding框架

这个框架是本篇文章要介绍的重点，也是我最近接触过的一款非常不错的 UI 框架。这款框架具有一个核心层，其底层源码不依赖于任何 UI 框架的，你可以以此为基础编写基于 UGUI 或者 NGUI 的 UI 框架。

框架的核心思想围绕着一个词 `Binding`，也就是所谓的“绑定”机制。框架中定义了两种数据类型：`Property`、`Collection`，所有的功能都是围绕着这两种类型进行的。在正式进行开发时，我们只需要在视图代码中定义这些数据类型，框架会对其进行获取并进行监听。但这样以来就有个问题，我们如何把这些自定义的数据类型绑定到框架中呢？很简单，使用反射即可。

我之前在公司编写界面代码时，一般是把所有的数据类型定义到一个 `Context`（上下文）中，每个界面都具有自己独立的上下文，以避免同名变量产生冲突。框架的核心功能就是用反射访问这些上下文，然后把所有的 Property 以及 Collection 收集起来，供视图组件进行操作。

UIBinding 的核心思想是基于 MVVM 的，即 Model、View、ViewModel，存在视图和模型之间的双向转换。

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/%E5%95%86%E4%B8%9A%E5%B8%B8%E7%94%A8UI%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88/UIBinding%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88.png)

上面展示了部分 Binding 组件，事实上整个框架包含各式各样的组件，比如 `TextBinding` 用于处理字符串，`BooleanBinding` 用于处理布尔值，`NumericBinding` 用于处理浮点数等。图片的上半部分展示的是框架的核心层，这一部分定义了基础的 Binding 组件，与上层的 UI 框架是无关的。图片的下半部分则展示的是框架的扩展层，这一部分会根据具体使用的 UI 框架扩展出相应的组件，比如 UGUI 扩展组件和 NGUI 扩展组件。如果你使用的是其他的框架，那么也可以做出相应的扩展。

可能各位看了图之后会有一些疑惑，比如处理图片的组件为什么会扩展自 TextBinding，NumericBinding 扩展出来的组件是干什么用的。事实上，不管是 UGUI 还是 NGUI，它们的组件功能基本都是类似的，比如文本组件用来显示文本，图片组件用来显示图片。那么问题来了，文本组件和图片组件的共同点是什么？

从代码的角度来看，文本组件的字符串表达的是文本内容，而图片组件的字符串则是图片路径，也就是说我们操作这两个组件时都是在修改它们的字符串。这样一来，我们就可以以 TextBinding 为基础扩展出 `UGUITextBinding` 和 `UGUIImageBinding`，这两个组件的作用就是修改文本内容以及更换图片。

再来看看 NumericBinding。该组件扩展出了 `CustomBoundsNumericBinding`，然后又进一步扩展出了 `PollingCustomBoundsNumericBinding`。前者的功能是将浮点数限制在一个范围内，而后者则是规定了浮点数的改变形式（视图改变数据、数据改变视图、双向）。这个又有什么用呢？相信各位已经看到了 `UGUISliderBinding` 是从 PollingCustomBoundsNumericBinding 扩展出来的，而滑动条组件通常会有数值的上下限。除此之外，PollingCustomBoundsNumericBinding 还能够调整值的改变形式，比如有些时候滑动条不允许拖动，只能够由数据来改变视图，又或者只能够拖动滑动条来改变数值等等。

最后是 BooleanBinding，它扩展出了 `ActiveBinding`。这个就很好理解了，布尔值本身就可以表示物体的隐藏与显示。另外，如果物体需要在两种状态之间切换，那么也可以用 BooleanBinding，比如买道具时如果钱够会显示白色，钱不够时要显示红色等等。

总而言之，这款框架的巧妙之处就在于，它能够抽离出各类组件的共性，并且尽可能地保持核心代码的纯净性。这样一来，当项目更换上层 UI 框架时，开发人员也能够迅速地扩展出一批新的组件投入使用，十分的便捷。

## 语言国际化问题

---

### 语言国际化的难点

就目前来说，国内的游戏厂商或多或少都会开发海外市场，所以项目使用的框架必须要能够支持语言国际化。可别觉得语言国际化就是个很简单的事情，因为不同的语言会有不同的字符，同一句话用中文来讲也许就几个字，而换成另外一种语言可能就变得很长，这也就意味着我们在做 UI 界面时需要考虑到界面的适配问题。这里顺带说一个小故事，当时在公司做项目时需要支持阿拉伯语言，然而阿拉伯语言是从右往左显示的，与 NGUI 默认的显示方式产生了冲突。我之前并没有参与到这个项目中，因此也不太清楚具体的情况，听同事说好像是需要去修改 NGUI 的底层，总之比较麻烦。

### 翻译文档的规范

那么如何让 UI 框架支持语言国际化呢？首先，我们要知道语言的翻译是怎么做的。以我所在的公司为例，项目的翻译文档通常是保存在谷歌文档中，使用时需要把文档下载来并转换成 JSON 格式（为了简化手动操作，这个步骤需要写一个编辑器脚本）。JSON 文件对应着各类语言，比如中文、英文、日文等等。以中文为例，文件的内容大概是如下所示：

```json
"Repository":"仓库",
"Amount":"数量",
"Plane":"飞机"
```

而换成英文可能就是这样：

```json
"Repository":"Repository",
"Amount":"Amount",
"Plane":"Plane"
```

换成日文或许是这样：

```json
"Repository":"リポジトリ",
"Amount":"量",
"Plane":"飛行機"
```

总而言之，所有翻译文件的字段都是相同的，唯一不同的就是字段所对应的翻译内容。这一部分工作最终都会交由专业的翻译人员完成，开发人员只需要提供那些待翻译的字段即可。

### 让UI组件支持国际化显示

既然翻译文本有了，那么如何让 UI 框架进行显示呢？首先，我们需要一个 `LanguageManager`，它的主要作用是从翻译文件中提取出字段所对应的翻译内容，比如 `LanguageMananger.GetValue("Repository")` 就能够获取 `Repository` 字段的值。其实当你完成了这一步之后，你已经能够用代码来实现语言国际化了，但为了开发的方便，我们希望能够直接在编辑器中完成这一步操作。比较直观的做法是在 TextBinding 组件中暴露一个公共变量，开发的时候可以直接填写对应的字段来实现语言国际化，比如你填入 `$Repository$` 就能够直接让文本内容变成对应的翻译内容。

我相信此时仍会有不少人觉得直接用代码来写要方便的多。然而，如果一个界面存在几十个文本组件，那么你就需要获取所有的文本组件并依次为其赋值，这无疑会让代码文件变得又乱又杂。更何况，有些文本是不会改变的（比如界面标题），如果能够直接在编辑器中完成国际化显然是更方便一些。