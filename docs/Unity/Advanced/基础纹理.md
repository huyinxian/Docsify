# 基础纹理

本篇笔记将对纹理这一概念作基本介绍，理清楚纹理在游戏开发中所起到的作用。

## 纹理

---

一般来说，我们会给物体覆盖上一张纹理贴图来代替物体的漫反射颜色。具体的做法其实很简单，我们只需要在之前的基础光照代码中加上纹理的属性即可：

```
Shader "Unlit/SimpleShader"
{
	Properties
	{
		_MainTex ("Main Tex", 2D) = "white" {}
		_Color ("Color Tint", Color) = (1, 1, 1, 1)
		_Specular ("Specular", Color) = (1, 1, 1, 1)	// 材质的高光反射颜色
		_Gloss ("Gloss", Range(8.0, 256)) = 20			// 高光区域大小
	}
	SubShader
	{
		Tags { "RenderType"="Opaque" }
		LOD 100

		Pass
		{
			Tags { "LightMode"="ForwardBase" }

			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			
			#include "UnityCG.cginc"
			#include "Lighting.cginc"

			sampler2D _MainTex;
			fixed4 _MainTex_ST;		// 用 纹理名_ST 命名即可获取纹理属性
			fixed4 _Color;
			fixed4 _Specular;
			float _Gloss;

			struct a2v
			{
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float4 texcoord : TEXCOORD0;
			};

			struct v2f
			{
				float4 pos : SV_POSITION;
				float3 worldNormal : TEXCOORD0;
				float3 worldPos : TEXCOORD1;
				float2 uv : TEXCOORD2;
			};
			
			v2f vert (appdata_base v)
			{
				v2f o;
				o.pos = UnityObjectToClipPos(v.vertex);
				o.worldNormal = UnityObjectToWorldNormal(v.normal);
				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
				// 存储uv坐标，计算时先对纹理坐标缩放，在加上偏移量
				// 可以用宏代替：
				// o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
				o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;

				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{
				fixed3 worldNormal = normalize(i.worldNormal);
				fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);

				// 纹理采样
				fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;

				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;

				// 半兰伯特，背面不会显得太黑
				fixed3 diffuse = _LightColor0.rgb * albedo.rgb * (max(0, dot(worldNormal, worldLightDir)) * 0.5 + 0.5);

				fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));
				fixed3 halfDir = normalize(worldLightDir + viewDir);

				fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);

				return fixed4(ambient + diffuse + specular, 1.0);
			}
			ENDCG
		}
	}

	Fallback "Specular"
}
```

在上述代码中，我们首先声明了一个纹理属性，然后在 CG 代码中定义 `_MainTex` 和 `_MainTex_ST` 两个变量。`_MainTex_ST` 相当于是纹理的偏移量和缩放量，我们只需要在 CG 代码中定义类似于 `纹理名_ST` 的变量即可拿到纹理属性（这是 Unity 帮我们自动完成的）。接下来，我们在顶点着色器传给片元着色器的结构体中新增了 `uv` 字段，这样一来片元着色器就可以获取对应的纹理坐标并加以运算。

效果大致如下：

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/%E7%AE%80%E5%8D%95%E7%BA%B9%E7%90%86.png)

?> 纹理图片的面板中其实有很多可以设置的属性，这里我就不作展开了，有兴趣的可以查看一下 Unity 的官方文档。

## 凹凸映射

---

### 什么是凹凸映射

我们在绘制物体时，经常会遇到需要绘制表面不规则物体的情况，比如下面这种：

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/normal_mapping_compare.png)

如果事先告诉你，你是否会认为右边的砖墙用的是另外的模型呢？当然这么想其实也没错，如果我们绘制一个高面数的模型，确实是能够达到预期的效果。然而作为游戏开发者，我们得时刻为游戏的性能表现和内存占用率着想，所以这种办法只能够暂时放弃掉了。

为了得出一个简单高效的解决方案，我们需要换一种角度，从光照的视角来看待这个问题：是什么决定了物体表面具有凹凸感？答案其实很简单，表面的法线向量决定了物体的形状。所以，我们并不需要真的去改变物体的顶点，仅仅只需要修改物体表面的法线向量，让光照相信该物体是凹凸不平的即可。

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/normal_mapping_surfaces.png)

之前我们所计算片元的法线，是对三角面顶点的法线进行插值得到的。那么当一个面上的所有片元都使用各自的法线时，凹凸感就出来了。这种让每个片元都使用各自法线的技术叫做**法线贴图**（Normal Mapping）。

### 法线贴图

为了让每个片元都能够使用各自的法线，我们需要提供一张法线贴图。然而，由于法线只表示方向，而方向又是相对于坐标空间而言的，我们该选择哪一种坐标空间来存储法线呢？

对于顶点所属的法线向量来说，它们是位于模型空间中的，所以第一种做法是把模型空间的法线修改过后直接存储在纹理上。不过在实际制作时，我们一般会采用另外一种坐标，即模型顶点的切线空间来存储法线。

由于法线是各个方向上都有的，因此它的取值范围在 `[-1, 1]`。如果要把法线信息存到一张 RGB 的贴图上，那么我们就需要将法线进行一些小小的变换：

$$ rgb = \frac{normal + 1}{2} $$

这样一来，法线信息就被存储到了范围为 `[0, 1]` 的贴图上。如果我们采用的是切线空间，那么法线贴图大概长这个样子：

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/normal_mapping_normal_map.png)

切线空间的法线贴图基本都是蓝色的，而模型空间的法线贴图则是五颜六色的。对于一个模型而言，每个顶点的切线空间都是不同的，但其位于切线空间下的法线向量大部分都是 $(0, 0, 1)$，也就是朝向 z 轴的。将这个向量用上面的公式进行转换后，得到的 RGB 颜色是 $(0.5, 0.5, 1)$（浅蓝色）。相比之下，由于模型空间下的法线朝向各个方向，所以得到的颜色就是五颜六色的。

如果物体表面不平整，那么切线空间下的法线向量就会发生偏移，转换后的颜色也就会有所不同，进而产生凹凸感。说白了，这种贴图存储的就是每个点在各自切线空间下的扰动方向，如果一个点的法线方向不变，那么它就是 z 轴方向。事实上，大部分顶点的法线是和模型本身的法线是一致的，并不需要改变。

那么为什么一定要多弄一个切线空间的法线贴图呢？其实用什么坐标空间都可以，我们最终是要拿这些数据来计算光照的。