# 网络编程基础

这一章主要讲一讲 TCP、UDP、HTTP 的基础概念，然后会结合 Unity 讲一些游戏开发过程中用的网络编程方法。

## 基本概念

---

### 七层网络模型

首先来看一下七层网络模型，你不一定每个都要搞懂，但是至少要知道：

* 应用层：为用户的应用程序提供网络服务，完成应用之间的工作。
* 表示层：对应用层的数据和命令进行解释，然后发送给会话层。
* 会话层：负责在网络中的两节点建立，维护节点之间的链接。
* 传输层：为应用层提供通信服务，接收会话层的数据并发送给网络层。TCP、UDP 协议处在这一层。
* 网络层：将网络地址翻译成物理地址，并建立网络连接。该层的设备为路由，单位为数据包，IP 协议也处在这一层。
* 数据链路层：即数据通道，在不可靠的物理网络上建立可靠的数据传递通道，主要用于物理地址寻址、数据检错、数据重发等。
* 物理层：即提供网络传输的物理设备。

一般来说，下四层提供数据传输和交换功能，上三层提供用户与应用程序之间的交互。

### TCP/IP四层模型

TCP/IP 是一组协议的代名词，包含了多种协议。TCP/IP 通常采用四层结构：

* 应用层：负责与应用程序沟通，如电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。
* 传输层：提供节点间的数据传递，如传输控制协议（TCP）、 用户数据报协议（UDP）等。
* 网络互连层：负责提供基本的数据封包传送功能，让每一块数据包能够到达目的主机（不保证能够被正确接收），如网际协议（IP）。
* 主机到网络层：对实际的网络媒体的管理，定义如何使用网络来传送数据。

### 网络通信基本概念

首先是 IP 地址。为了能够实现网络中不同终端之间的通信，每个终端都得有一个唯一标识，也就是 IP 地址。

其次是端口号。一台终端上会有多个应用程序，端口号则是用来区分不同的应用程序。

?> 端口号的范围为0-65535，0-1023 为系统保留端口，一般不要使用。

### TCP的连接与关闭

TCP（传输控制协议）是面向连接的协议，即在收发数据时要保证和对方建立**可靠**的连接，所以使用的是 C/S（客户端/服务端）架构。TCP 的建立需要经历三次握手，图示如下：

![](http://cdn.fantasticmiao.cn/image/post/Unity/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01.jpg)

这里简单解释一下各个符号的含义：

* SYN：代表请求创立连接。
* FIN：代表请求关闭连接。
* ACK：代表确认接受。
* seq：序列号，用于对每个数据包进行编号。由于发送的数据会被拆分成多个数据包，因此需要序列号来保证数据包的顺序。
* ack：代表下一个数据包的编号。

在建立连接时，客户端首先发送连接请求，服务端收到后表示接受连接。虽然此时就代表连接成功了，但是为了以防意外，客户端需要再发送一次消息给服务端确认。

TCP 在关闭连接时需要经历四次分手，图示如下：

![](http://cdn.fantasticmiao.cn/image/post/Unity/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02.jpg)

TCP 是双向连接的，关闭时需要客户端和服务端都关闭才行。

### 三次握手与四次分手

为什么需要三次握手呢？明明两次就能够建立连接，为何还要多加上一次确认呢？我们来看看这样一种情况：现在有一个连接请求跑得太慢，超时了，此时客户端就会重新发送一遍请求。但是这个跑得慢的连接请求最终还是到达了服务端，然后服务端就会因此创建两个连接。但是如果加上了第三次握手，那么客户端再次接受到服务端的确认请求后就可以不管，避免创建多余的连接。

至于为什么要四次分手，我们可以看一下四次分手都干了些什么：

* 当客户端确认发送完数据，并且知道服务端已经接受完了，此时客户端就会发送 FIN 给服务端表示想要关闭连接。
* 服务端接收到 FIN，发送 ACK 表示确认接收。
* 但是服务端此时有可能还在发送数据，并不想关闭连接，因此 ACK 和 FIN 不是同时发送的，只有当服务端发完数据后才会发送 FIN。
* 客户端收到 FIN，回复服务端 ACK 表示确认接收。此时客户端需要等待 2MSL，如果再也没有收到服务端的消息，客户端才会关闭连接。

我们可以用比较形象的描述来解读三次握手和四次分手。首先是三次握手：

* 客户端：“喂，听得到吗？”
* 服务端：“听得到，你能听到我说话吗？”
* 客户端：“我听得到你说话。”

四次分手：

* 客户端：“喂，今天先到这吧。”
* 服务端：“好我知道了，等我先说完刚刚的那件事……”
* 服务端：“好了我说完了，那么再见吧。”
* 客户端：“嗯，再见。”

可能有人不太理解，为什么客户端要进入 TIME_WAIT 等待 2MSL。各位可以想想，客户端最后发送的 ACK 是有可能丢失的，如果服务端一直收不到客户端的 ACK，那么它就会一直发送，所以客户端的连接不能够中断，否则 TCP 就会给服务端报错。所谓的 MSL，指的是一个包在网络中的最大存活时间，而 2MSL 就是一个发送和一个回复所需的最大时间。如果过了 2MSL 还没有收到服务端重发的消息，证明服务端已经接收到了客户端的 ACK，此时就可以关闭连接了。

### UDP

UDP（用户数据报协议）是非连接协议，传输数据前不用建立连接，想传的时候就直接传。相比较于 TCP，UDP 是不可靠的，数据的先后顺序通常无法保证，且不具备数据的完整性。一般来说，UDP 通常用于网络较差的情况，或者是对于数据的完整性没有很高要求的场合（例如直播）。

UDP 的信息包很小，并且传输速度只受软件产生数据的速率、传输带宽、源端和终端的性能限制。UDP 是面向报文的，对于应用层发下来的报文，加上首部后即可交给 IP 层，不用像 TCP 那样进行拆分，因此应用程序需要选择合适的报文大小。

### 粘包与拆包

TCP 经常遇到的一个问题就是粘包与拆包，为了解释该问题的由来，我们得先了解 TCP 的传输方式。TCP 连接是双向的，发送端为了提高发送效率，通常会采用优化算法，将多个间隔短且体积小的包合并成一个大包，或者是将一个大包拆分成多个小包。一般来说有以下三种情况：

* 接收端正常收到两个数据包，既没有发生粘包和拆包。
* 接收端只收到了一个包，也就是说发送端把两个数据包合并成了一个，形成了粘包现象。
* 接收端收到了两个包，但这两个包要么多一块要么少一块；或者接收端收到了两个以上的包，而这些包都缺少了一部分，形成了拆包现象。

发生粘包和拆包的原因有很多，比如发送的数据大于 TCP 发送缓冲区的剩余大小（拆包）、待发送数据大于最大报文长度（拆包）、发送数据小于 TCP 发送缓冲区的大小（粘包）等等。

有人可能会问，UDP 会不会有粘包拆包呢？答案是不会的，因为 UDP 是基于报文发送的，UDP 首部会指示报文的长度，因此应用层会把不同的数据报文进行区分，发送和接收都是一次一个。相比较之下，TCP 则是把数据块看做一连串无结构的字节流，首部并没有记录数据长度，因而是没有边界的。况且 TCP 在发送和接收时会把数据写入到缓冲区中，虽说这样可以减少发送和接收次数，但也非常容易导致粘包和拆包现象。

解决粘包拆包的方法如下：

* 给每个数据包添加首部，记录数据包的长度，这样接收端就能够知道每个包的实际长度。
* 将数据包的长度固定，不够的用 0 补，接收端每次读取缓冲区时只会读取固定长度。
* 在数据包的使用特殊字符分割。

### Socket

Socket（套接字）用来描述 IP 地址和端口，应用程序可以通过 Socket 向网络发送请求或者应答请求。Socket 是支持 TCP/IP 的基本操作单元，包含连接所用的协议、本机 IP、本机端口、终端 IP、终端端口。

Socket 的通信步骤如下：

* 服务端创建 ServerSocket 等待连接。
* 客户端创建 Socket 连接服务端。
* 服务端接收到请求后创建 Socket，连接成立。
* 按照协议进行数据读写。
* 关闭输入输出流以及 Socket。

### HTTP

HTTP（超文本传输协议）是万维网用于从服务器传输文本到本地的一种协议，基于 TCP/IP 协议来传递数据（图片、HTML、文本等），采用的是 C/S 架构。

特点如下：

* 无连接，即每次只处理一个请求，当服务器处理完客户的请求，并收到客户的应答后，即断开连接。
* 媒体独立，也就是说只要客户端和服务端知道如何处理数据，任何类型的数据都可以用 HTTP 发送。
* 无状态，即协议对于事务处理没有记忆能力，如果后续处理需要前面的信息，需要重新传输。

常用的请求方式有 Get、Post。Get 请求会把参数直接放到连接中，而 Post 请求则会通过一个请求体来传输，因此一般使用 Post 居多。

## 游戏信息同步

---

所谓的同步，就是为了让多个客户端的表现效果统一。比如我们在玩 FPS 游戏，那么就需要保证所有玩家的电脑上能够准确显示人物的位置、血量、子弹数量，只要有一个不同就会给玩家带来极为糟糕的体验。

游戏中的同步方式一般有两种：状态同步和帧同步，它们的主要区别就在于核心逻辑写在哪里。状态同步的逻辑写在服务器，而帧同步的逻辑则是写在本地。

?> 战斗逻辑视具体游戏而定，通常包括技能、攻击、BUFF、治疗、移动、碰撞、AI 等等一系列的内容。

### 状态同步

最具代表性的状态同步游戏应该是 MMORPG。以魔兽世界为例，一个大场景中可能有成百上千个玩家，而核心逻辑必须要得到场景中所有的实体，客户端不可能也不需要把所有的实体展现出来（比如超出视野范围的玩家就不用显示了），因而魔兽世界的战斗逻辑是放到服务器上的。

说的更具体一点，在状态同步下，客户端可以视作是服务器的表现层，人物的血量、攻击、属性等信息都是服务器传给客户端的，且在状态改变时服务器会实时通知客户端进行变更。由于主要的逻辑都在服务器上，所以本地修改客户端其实是没有效果的，例如你修改了无限血量，但服务器的判定你已经死亡，你再怎么改也是没有用的。

再举个例子，当玩家释放一个技能时，客户端会通知服务器，然后由服务器计算技能的朝向、飞行时间、什么时候碰撞到敌人、造成多少伤害等。最终，客户端会把这一系列动作呈现给玩家。

状态同步优点如下：

* 容易做断线重连。
* 容易做反作弊。

状态同步的缺点如下：

* 数据流量大，一个人物可能有上百种属性，每次改变都要进行同步，非常消耗流量。
* 打击反馈不精确，因为所有的表现都是由服务器推送的，在网络波动的情况下很难做到契合。
* 对网络要求很高。
* 服务器需要实现逻辑，且对于服务器的压力很大。

### 帧同步

最具代表性的帧同步游戏应该是 MOBA 和 RTS 游戏。帧同步的逻辑是写在客户端的，当某个玩家做出操作时，客户端会把操作发给服务器，然后经由服务器转发给其他的玩家，最后在客户端上播放这个操作。由于每次发送的都是操作（比如前进、放技能），因此数据量比较小，消耗的流量也没有状态同步大。

早期使用帧同步的著名游戏有星际争霸和魔兽争霸。由于一局比赛中通常会有几百个单位，使用状态同步的话对于网络是个比较大的挑战（特别是当时流行局域网），而如果仅仅是同步操作的话则会大大减轻网络压力。此外，使用帧同步非常有利于做战斗回放，例如星际争霸的回放系统就是将所有玩家的操作重新进行运算，观看者可以选择任意时间、任意位置进行查看，且产生出来的播放文件也非常小（因为只记录了操作）。

但相比于状态同步，帧同步的实现非常麻烦，有大量的坑需要填。首先，帧同步需要把逻辑和表现分离，例如 Unity 中的 Invoke、Update、动画系统、碰撞检测等等都得重新写，做到逻辑与渲染的完全分离。为什么要这样呢？这是因为帧同步只传了操作，我们要想让所有客户端的表现统一，就必须要做到同一个操作输出同样的结果，否则帧同步就是失败的。像是随机数要统一随机数种子，保证随机数一致；浮点数要改成定点数，避免不同机型的精度不一样导致游戏不同步等等。

其次就是锁帧问题。服务器会等待所有客户端的第 n 帧操作到齐后再进行发送，假如有一个客户端因为网络波动超时了，那么就得判定这个客户端没有做操作。除此之外，即使某一帧玩家没有进行操作，那也得发送空包。

然后还有逻辑帧平滑问题。客户端一般会按照队列来执行操作命令，假如队列过长，那么就会显得操作有延迟；假如队列过短，那么就会造成逻辑帧不平滑。解决办法就是做到渲染与逻辑分离，并且使用平滑插值。举个例子，卡顿感主要是因为人物移动不平滑。如果我们以人物移动方向为准来进行计算，那么即使没有逻辑帧，人物的表现也是会按照当前的速度进行运动。

?> 这里只是做一个简介，具体的内容还是要在之后的笔记中进行讲解。

帧同步的优点如下：

* 打击反馈好，因为逻辑都在本地。
* 网络流量小，适合手机平台开发。
* 适合做战斗回放。
* 服务端实现简单。

缺点如下：

* 客户端实现比较复杂，需要考虑多方面因素。
* 反外挂能力差，容易被修改本地客户端。
* 断线重连不太好做，服务器需要把断线时间内的所有操作发给客户端，然后让客户端加速播放来进行追帧。
* 对于结果的要求非常严格，需要注意浮点数、随机数、容器访问顺序等问题，必须做到一个操作对应同一个结果。