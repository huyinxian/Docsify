# PureMVC设计思路

经过上一章的学习，我们大概了解 PureMVC 的基本流程，也或多或少地发现了它与 MVC 架构的不同之处。那么这一章我就讲详细地讲一讲 PureMVC 的设计思路。

## PureMVC与MVC

---

如果你看过俄罗斯方块那一章，那么你应该会有一种很奇怪的感受。虽说整个项目是按照 MVC 的结构进行开发，视图层与模型层也没有实际的关联，但控制层与视图层的交互未免也太多了些，而且模型层也不单单是用来存储数据，还保留有一些对外的接口。这里固然有设计上的失误，但也反映出了 MVC 的一些问题。

相比较而言，我们之所以要拆分软件，降低它们的耦合度，主要还是为了项目开发的分工以及应对不断变化的需求。PureMVC 在原有 MVC 的基础上引入了中介者模式和事件通知机制，降低了视图层与控制层的耦合度。当然，零耦合度就意味着各部分完全没有关联，这也是不行的，所以事件通知机制就用来解决这一问题。

?> PureMVC 不止使用了上述的两种模式，其他的设计模式我们放到之后再讲。

## 中介者模式和事件通知机制

---

中介者模式（Mediator Pattern）是一种设计模式，旨在通过一个媒介对象，完成一组对象的交互，避免对象间相互引用，产生复杂的依赖关系。一般来说，如果我们要在某个类中调用别的类，那么就必须显式的声明这个类，但这样一来就会让项目变为了紧耦合，偏离了我们的初衷。中介者模式正是用来降低项目的耦合度。

在模型层、视图层、控制层被划分出来之后，剩下的问题就是如何把它们连接起来。在这一个问题上，事件通知机制起到了关键的作用。事件机制可以让当前对象专注于自己的职能，而不必去关心其余的功能是如何实现的。打个比方，客户端开发只需要专注于前端的事情，而服务端怎么实现功能则不需要客户端来管。

话是这么说，但这与直接显式调用别的类又有什么区别呢？其实，事件通知机制并不是一对一的关系，它更像是一种广播。当某个对象广播一个事件时，只有对该事件感兴趣的对象才会响应，其他不感兴趣的对象则会把这个事件忽略掉。基于这种机制，当前对象与响应对象之间不存在依赖关系，甚至可以说不知道对方的存在。

## 分析HelloPureMVC

---

上一章我们写了一个简单的 Demo，介绍了 PureMVC 框架的基本开发流程。在了解了中介者模式和事件通知机制后，我们再来分析一下这个流程。

### 全局管理类

`ApplicationFacade` 继承自 `Facade`，我们在这里注册三个层，并且把一个消息绑定到控制类上。当某个对象广播这条消息时，控制类就会响应这个消息并调用相关的方法。

### 模型层

模型层只负责存储数据，它不关心这个数据要进行什么运算。

### 模型层代理类

代理类负责数据的相关运算，并且提供了一些对外的接口。

### 视图层

视图层中引入了 UI 控件，不过这也带来了一个问题，那就是如何找到这些控件。在一般的项目工程中，继承自 MonoBehavior 的类可以通过 `Find` 方法来查找游戏对象，但视图层做不到这一点。为此，我们需要向视图层传入 UI 层的根节点，然后通过根节点找到 UI 控件。在 Demo 中，传入的操作由 `StartGame` 类来完成。

另外，视图层中定义了按钮的响应方法，当按钮按下时会广播控制层绑定的消息，从而调用控制层中的方法。至于为什么会自动调用 `Execute` 方法，这个得等到分析 PureMVC 源码时才能知道。