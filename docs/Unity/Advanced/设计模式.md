# 设计模式

设计模式是有经验的软件开发人员总结出来的解决方案，可以用于解决软件开发过程中遇到的一般问题。设计模式可以使软件编码更规范，提高代码的可靠性。

## 设计原则

---

### 开闭原则

对扩展开放，对修改关闭。该原则是为了提高程序的扩展性，禁止对原有代码进行修改。想要实现这一点可以使用接口和抽象类。

### 里氏代换原则

该原则是对开闭原则的补充，即任何父类出现的地方，都可以用子类进行替换。也就是说，派生类只是对于父类的功能进行扩展，所以可以用派生类来替换掉父类。开闭原则的关键是抽象类，而里氏替换原则就是对实现抽象的规范。

### 依赖倒转原则

即针对接口编程，依赖于抽象而不依赖于具体。

### 接口隔离原则

使用多个隔离的接口，比使用单个的接口要好。说白了就是把功能独立出来，降低程序的耦合度。

### 迪米特原则

一个实例要尽可能少地与其他实例进行交互，使得模块功能相互独立。说得简单的就是降低模块间耦合度。

### 合成复用原则

尽量使用合成、聚合，而不是使用继承。

### 总结

可能你对上面的某些原则存在疑惑，不过你只需要记住一点，设计模式的原则就是做到**高内聚、低耦合**。高内聚指的是类成员之间的关系，低耦合指的是类与类之间的关系。继承是耦合度最高的一种关系，所以合成复用原则中才会推荐我们使用合成、聚合的方式。就算我们一定要用继承，也应该使用简单的继承关系，或者直接继承抽象类而非实现类。

至于合成和聚合，其实就是提醒我们要让模块的功能高度集中，不相关的成员不要写到一个类中。如果我们写许多乱七八糟的成员或者静态成员，就会破坏类的内聚性。

## 设计模式

---

### 代理模式

代理模式是为一个现有的类创建一个代理类，然后通过这个代理类对外界提供接口。

很多时候，直接访问对象会带来一系列问题，比如对象创建开销很大、某些操作需要安全控制等等。为了避免这种情况，我们可以在此对象上加上一个访问层。不过呢，这样做虽然可以划分职责，扩展性也很高，但是由于实体类和访问对象中间加了一层代理，所以会导致请求的处理速度变慢。

### 中介者模式

中介者模式用于降低多个对象之间的通信复杂度。该模式提供了一个中介类，可以处理不同类之间的通信。

如果对象之间的关系极为复杂，那么当一个对象发生改变时，我们就必须要去处理所有与之关联的对象。为了解决这一问题，我们需要把对象之间的关系重新组合为星型结构，使用一个中介者来进行对象与对象之间的通信。这样，对象就只需要与中介者进行沟通，将一对多的关系转变成一对一。最具典型的例子就是 MVC 架构，里面的控制器就是模型与视图的中介者。

中介者模式也有它的缺陷。当对象过多时，中介类可能会变得非常庞大，增加维护成本。

### 观察者模式

当对象之间存在一对多关系时，我们就可以使用观察者模式进行解耦。

举个例子，我们可以把对象的改变看做是一次事件，而所有对于这次事件感兴趣的对象则是观察者。当该事件发生时，观察者们就会收到通知，进而做出相应的处理。观察者与被观察者之间是抽象解耦的，被观察者只负责发送事件，但它并不知道有哪些对象会接收该事件。因此，我们必须实现一套触发机制，能够在事件发生时通知到所有的观察者。

观察者模式的缺点很明显，当某一对象的观察者过多，通知一次事件会花费掉很多的时间。另外，观察者模式只能够让观察者知道目标发生了变化，但具体怎么变化的就不清楚了。

### 命令模式

该模式会把请求封装成对象，以便用不同的请求来参数化其他对象。

由于请求是以对象的方式存在，因此它可以被存储和传递，从而实现行为请求者与行为实现者之间的松耦合。命令模式的本质是对命令的封装，将发出命令和执行命令的职责分离。

命令模式的优点有：类之间解耦、扩展性高、易于其他模式组合，但缺点是命令过多时会让类变得很大。命令模式比较适合实现撤销、重做、回放、时间回退等功能。

### 外观模式

外观模式主要是为了将复杂的系统隐藏起来，对外提供一个可以方便访问的接口。

实现外观模式需要在客户端和复杂系统之间增加一个访问层，该访问层与系统进行耦合，对系统内复杂的访问方式进行梳理和归纳，并对客户端提供简单的访问接口。该模式的优点有：减少系统相互依赖、增加灵活性、增加安全性，不过缺点则是违反了开闭原则，很难扩展访问层。