# ECS入门

这篇笔记将介绍 Unity 最新提供的 ECS 框架。ECS 框架其实很早就存在了，只不过很少会有公司去使用而已。在开始介绍 ECS 前，建议各位先看看暴雪在 GDC2017 做的技术分享：[《守望先锋》架构设计与网络同步](https://gameinstitute.qq.com/community/detail/114516)。

## ECS概述

---

### 什么是ECS

ECS 即 Entity（实体）、Component（组件）、System（系统），这三大元素构成了 ECS 框架。该框架的核心在于 Component 和 System。

Entity 可以看做是对象，但和一般的游戏对象（比如 GameObject）不同，它仅仅只包含数据，不包含方法。实体对应一个 ID，它是由多个组件所组成的集合，其意义在于生命周期的管理。

Component 可以认为是对象属性，它是无行为的，所有可以单独使用的对象都可以作为组件，比如对象的名称可以是一个组件，对象的位置又可以是一个组件。每个 Entity 都是由多个 Component 组成，共享一个生命周期。

System 可以看做是模块，它是无状态的。ECS 中的 System 不同于一般意义上的系统，每个模块只专注于干好一件事情。举个例子，碰撞系统只关心对象的体积和位置，不关心对象的名称、音效、特效等等属性。它也不一定会关心游戏世界中的所有对象，比如有些装饰物不会参与碰撞。因此对于每个系统而言，有必要筛选出所有它感兴趣的对象。

### ECS与OOP

很多游戏引擎都是根据面向对象来设计的，游戏中的各种东西都可以是对象。每个对象都有一个 Update 方法，框架会依次遍历所有对象的 Update 方法，然后执行相应的逻辑。Unity 中提供了多种 Update 方法，以供开发者在同一帧的不同时机调用。

这种做法有很多缺陷，因为游戏对象通常是许多部分的集合，而不同业务模块所关心的部分往往是不同的，比如渲染模块不关心网络连接，碰撞检测模块不会关心玩家的属性、道具等。虽然把游戏对象的各种属性聚合在一起形成对象是没错的，但对于不同的模块而言，如果针对聚合对象做处理的话，会让模块的内聚性变差，模块间也会产生不必要的耦合。我们在实际开发时为了减少误差，可能会让服务端和客户端共用一部分代码。如果客户端的代码耦合较为紧密，那么可能就无法做到这一点。

ECS 框架的业务循环就是在调用不同的系统，每个系统都会遍历自己感兴趣的对象，而那些不感兴趣的则不会去管看。对于守望先锋这类游戏来说，ECS 框架是很符合其需求的。比如 A 攻击了 B，那么这件事情就是发生在 A 和 B 之间。传统的框架中你经常会纠结伤害计算放在 A 的方法中还是 B 的方法中，而 ECS 则只需要放在伤害计算系统中即可，这个系统只关心那些与伤害有关的一小部分数据集合。

总之，ECS 框架就是把复杂的问题拆分开来，提高每个子系统的内聚性。

## Unity ECS

---

### Unity为什么要推出ECS

ECS 的框架特点我在上面已经介绍过了，但有一个问题我们还没搞清：Unity 为什么要迈这么大一个步子？

以前我们基于 GameObject/MonoBehavior 模式能够很轻松地开发游戏，但随着游戏的复杂度提升，往往会让代码变得难以阅读和维护。这个问题是由许多因素导致的，比如 OOP、由 Mono 虚拟机编译的非最优机器码、GC 机制、单线程开发等等。相信用过一段时间 Unity 的开发者都会有类似的感触。

有人会觉得往 GameObject 上挂 Component 就是一种 ECS 结构。事实上这是不对的，因为 Unity 中的 Component 是一个完整的类，它包含许多方法。另外，ECS 结构需要有过滤功能，也就是要能够获取所有“拥有 ComponentA 的 GameObject”，这在传统开发模式中是做不到的。

### 传统做法的优缺点

我们先看一下如何在 Unity 中创建一个游戏对象：

* 创建 GameObject
* 在对象身上挂各种组件
* 创建 MonoBehavior 脚本挂到对象上，把各种需要的组件赋值给脚本，然后编写相关控制逻辑

上述步骤是 Unity 开发的基本流程，这种做法比较方便和直观，但由于其代码逻辑与具体的数据相关，因此就会造成代码重用率低下。除此之外，GameObject 与它依赖的组件也是分散在堆内存中的，如下图：

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/ECS%E5%85%A5%E9%97%A8/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8.png)

虽然 Unity 可以快速构建游戏场景，但是它的性能一直都不是很好。我们在享受着面向对象编程的便利时，也不得不承受其缺陷所在。举个例子，我们写脚本时通常都会继承 MonoBehavior，但绝大部分时候我们都只需要使用里面的某些函数或者变量。这样一来，未使用的部分无疑就造成了空间浪费。

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/ECS%E5%85%A5%E9%97%A8/%E7%A9%BA%E9%97%B4%E6%B5%AA%E8%B4%B9%E9%97%AE%E9%A2%98.png)

以上图为例，我们编写了一个移动脚本，那么理应要访问 Transform 组件。事实上，脚本中仅仅用到了 `position` 和 `rotation` 这两个变量，其他的全都没用上。当程序运行时，这些未使用的部分将会被填充一些无用数据。

### ECS实体组件系统

为了解决传统模式所带来的空间浪费问题，我们可以使用 Unity 最新推出的 ECS 框架。下面展示的是一个实体组件系统的作业图：

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/ECS%E5%85%A5%E9%97%A8/%E5%AE%9E%E4%BD%93%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F.PNG)

请注意，上图中的实体数据没有挂载其他乱七八糟的脚本，比如 Bullet 就没有挂载 Transform、RigidBody 等组件，它仅仅包含数据。这种设计也是 ECS 的核心思想，即把数据和逻辑进行分离，提高程序的运行效率。

光是这么说可能各位感觉不出来，我可以给大家看一张图：

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/ECS%E5%85%A5%E9%97%A8/%E7%A9%BA%E9%97%B4%E5%88%A9%E7%94%A8%E7%8E%87%E5%AF%B9%E6%AF%94.jpg)

第一张图代表传统的 Unity 使用方式，也就是挂载 Transform 组件。由于 Transform 中会有大量未使用到的变量，因此需要额外占据一部分空间。第二张图代表的是 ECS，它的实体数据是线性排布的，能够大大提高内存的访问速度，并且其空间利用率也很高。各位在看图的时候可以注意一下缓存行存储中的内存碎片。

我们可以再对比一下单个移动操作所需要花费的内存：

![](http://cdn.fantasticmiao.cn/image/post/Unity/Advanced/ECS%E5%85%A5%E9%97%A8/%E5%8D%95%E4%B8%AA%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E6%89%80%E9%9C%80%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94%E5%9B%BE.jpg)

上图中，左边代表是传统方式，即访问 Transform 组件来控制移动，而右图则是使用的 ECS 框架。显然，在达成相同目标的前提下，ECS 的效率要更高。

回到 ECS 的概念上来，实体只是一个 ID，或者说索引，用于表示一个数据集合。系统可以根据其需求，自动对所有组件进行过滤，筛选出它感兴趣的组件并对其进行操作。这种系统与实体分离的设计无疑能提高游戏的运行效率，并且还能支持在需要使用内存对齐的现代 CPU 中采用先进技术（自动矢量化/SIMD）。