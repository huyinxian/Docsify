# Unity中的Lua

Lua 做为一门解释型语言，经常用于各类游戏开发之中。那么，在 Unity 中，我们为什么要使用 Lua，又该如何去使用呢？

## 为什么要使用解释型语言

---

一提到游戏开发所用的语言，我们想到的可能就是 C++、C# 这类高级语言。这些语言虽然功能强大，但其实很难满足游戏行业内不断变化的需求。试想一下，如果游戏需要有一个重大的更新，那么我们就必须重新把项目编译一遍，之后再打包上传至服务器。这一过程对于开发者来说没什么，但对于玩家而言，如果每次更新都需要重新下载安装包的话，绝对会让玩家给游戏打上差评。

就目前而言，游戏业内普遍采用的做法是把底层逻辑交给 C++、C# 等高级语言，然后把上层逻辑交给解释型语言。打个比方，游戏内的战斗逻辑一般是不会改变的，那么这一部分就可以用 C# 实现，提高游戏的效率，而对于游戏中常常变动的 UI、活动等部分，就可以交给更灵活的解释型语言。不过呢，不同的公司有不同的做法，有的公司喜欢全部用 C# 写，尽量做到高度可配置，然后采取上传 DLL 文件进行替换更新的方法来修复 BUG，而有的公司则全部都用 Lua 来编写代码，做到全面的热更新。孰优孰劣，都是看各自的需求罢了，并没有一种绝对的方案。

不过遗憾的是，哪怕安卓平台上可以下载脚本进行替换，但 IOS 平台是绝对不可以的。所以，开发者只能够上传完整的安装包或者用 Lua 来进行更新。

## 什么是Lua

---

简单的说一下，Lua 在开发之初就是为了嵌入应用程序中，为程序提供高可扩展性。Lua 由 C 编写，其本身极为小巧轻便，效率在各类脚本语言中也属于前列。除此之外，Lua 也支持面向对象和函数式编程，其提供的 table 表十分强大，可以实现各类功能。更重要的是，Lua 与其他语言可以很快的结合起来，这也是为什么要选择用 Lua 来作为热更新的脚本语言。

## Lua基础

---

### table

Lua 的数据类型不多，值类型有 `nil`、`number`、`string`、`boolean`，引用类型有 `function`、`userdata`、`thread`、`table`。其中，我们最需要掌握的就是 table 表。什么是 table 呢？table 是一个**关联数组**，索引可以是数字或者字符串，创建的方式为 `{}`。它的形式很像 C# 中的 Dictionary，但是二者之间还是有很大不同的。

table 的默认索引从 1 开始，如果你想要指定键值的话可以使用 `[]`。如果不好理解的话可以这么想，凡是被指定了键的元素可以被视作 Dictionary，而没有指定键的元素则可以看做是数组。可以看看下面的例子：

```lua
myArray = { 100, 200, [0] = "one", ['key'] = "value", "two" }
```

table 的遍历方式一共有三种，基本 for 循环、ipairs、pairs。`ipairs` 只能够遍历默认索引，并且遇到空值时就会停止；`pairs` 可以遍历 table 中的所有元素，但是其遍历顺序是先数组后 Dictionary，比如上面的这个表的打印结果为：

    1       100
    2       200
    3       two
    0       one
    key     value

如果你用的是 `ipairs`，那么结果如下：

    1       100
    2       200
    3       two

顺带一提，如果你想要获取 table 的长度，最好自己用循环来判断，因为 `#` 只能够获取数组的长度。还是以上面的表为例，因为表中只有三个默认索引的元素，所以输出的结果为 `3`。

这样就完了吗？当然不是，如果 table 只具备上面的功能，那它也仅仅只是个普通的存储结构罢了。除开默认索引和键，我们还可以在 table 中存储变量和函数：

```lua
function myPrintFunc(val)
    print(val)
end

myTable = { key = "value", myPrintFunc = myPrintFunc}

myTable.myPrintFunc(myTable.key)
```

访问 table 中的变量和函数使用的是 `.` 运算符，你可以使用它为 table 中变量赋值或者定义方法：

```lua
myTable = {}
myTable.key = "value"

function myTable.MyPrint(val)
    print(val)
end

myTable.MyPrint(myTable.key)
```

这种用法是不是有点眼熟呢？别着急，我们接着往下看。

### 元表

什么是元表呢？你可以把它理解为 table 的附加物或者背包，当 table 中找不到元素时，就会到它的元表中去寻找：

```lua
newTable = { key = "value" }

setmetatable(newTable, { __index = function()
    print("__index")
end})
```

`__index` 是元表中最常用的键，当你通过键来访问 table 时，假如这个键没有值，那么 Lua 就会寻找该 table 的元表中的 __index 键。如果 __index 包含一个表，那么 Lua 就会在表中寻找相应的键；如果 __index 包含一个函数，Lua 就会调用该函数，table 和键可以作为参数传递给函数。

总而言之，Lua 在查找一个表时分为以下步骤：

* 在表中查找元素，如果找到就返回该元素，找不到则继续下面的步骤
* 判断该表是否有元表，没有元表返回 nil，有的话就继续
* 判断元表中有没有 __index 键，如果 __index 是一个方法，那么调用它；如果 __index 是一个表，则重复上述步骤

?> 元表中除了 __index，其实还有其他的键，如果感兴趣各位可以自行了解。

### OOP

元表的功能似乎很有趣，但它具体有什么作用呢？事实上，这正是 Lua 用来实现 OOP（面向对象编程）的主要手段。

假设有一个父类，它定义了公有变量 `age`，而继承自它的子类则定义了变量 `sex`。当我们调用子类的元素 sex 时，显然是能够得到对应的结果的，但如果我们调用的是 age 呢？学过高级编程语言的人应该都清楚，子类可以继承父类的公有变量，所以就算子类并没有定义过 age，它依旧可以返回父类所定义的变量。

这种继承的形式其实就和 Lua 查找 table 是一样的，我们可以把 table 的元表视作是它的父类，当 table 中没有某个键时，就会去搜索它的父类中是否有这个键。如果这一块有点搞不懂的话，建议仔细读一读我上面写的 Lua 查询表的步骤。

在开始介绍 Lua 如何实现 OOP 之前，我先讲一下 `.` 和 `:` 的区别。它们都可以用来定义方法，只不过使用 `:` 会默认传入一个参数 `self`，这个 self 其实就是调用该方法的 table 表。所以，我们在写类方法的时候，最好都使用 `:`。

下面是一个简单的类实现：

```lua
classA = { value = 0 }

function classA:new(o)
    local o = o or {}       -- 如果没有提供对象，就自行创建
    setmetatable(o, self)   -- 将o的元表设置为classA
    self.__index = self     -- 这一步很关键，我们可以通过元表来访问classA
    return o
end

myClass = classA:new()
print(myClass.value)
```

我们来看看上述代码都干了些什么。首先，我们定义了一个表 `classA`，然后为其添加了一个变量 `value`。随后我们为这个表定义了一个方法 `new`，然后创建了一个空表。为了能够访问 `classA`，我们需要把空表 `o` 的元表设置为 `classA`，并且把元表的 `__index` 键设置为 `classA`。这样一来，当我们访问 `o` 时，由于它是一个空表，自然就会到元表中去寻找元素，从而达到了访问 `classA` 的目的。

我之前也有说过，任何表都可作为其他表的元表，自身也可以成为自身的元表，上述代码就是借助了这一概念。另外，如果子类自己定义了与父类同名的变量或者方法，就会覆盖掉父类的变量和方法（因为只有当子类找不到索引时才会去查询元表）。

### 协程

协程与线程比较类似，拥有独立的堆栈，独立的局部变量，独立的指令指针等。它与线程的区别在于，多个协同程序需要彼此协作执行，也就是说任意时刻只能够有一个协程在执行，并且这个在运行的协程只有被明确要求挂起时才会被挂起。

协程的基本语法如下：

* coroutine.create()：创建协程，并返回这个协程，参数为一个函数。
* coroutine.resume()：启动协程。
* coroutine.yield()：挂起协程，并将参数返回。
* coroutine.status()：查看协程的状态。有 dead，suspend，running 三种。
* coroutine.wrap()：创建协程，并返回一个函数，参数为一个函数。
* coroutine.running()：返回正在执行的协程。协程也是一个线程，返回的是协程的线程号。

先来看一个例子：

```lua
co = coroutine.create(function (a)
    local r = coroutine.yield(a + 1)    -- yield()返回a+1给调用它的resume()函数，即2
    print("r=" ..r)                     -- r的值是第2次resume()传进来的，100
end)
status, r = coroutine.resume(co, 1)     -- resume()返回两个值，一个是自身的状态true，一个是yield的返回值2
coroutine.resume(co, 100)               -- resume()返回true
```

resume 用于启动协程，它会默认返回一个 boolean 值，用于表示协程是否启动成功。如果调用的协程中有 yield 方法，那么它还会返回 yield 的参数。

yield 用于挂起协程，在上述的例子中，协程在第一次启动时，会运行到 `local r = coroutine.yield(a + 1)` 时挂起。当我们再次启动协程时，才会执行后面的 `print("r=" ..r)`。

协程有三个状态，当协程创建时，其状态默认为 `suspend`；当协程被 resume 调用时，协程的状态为 `running`；当协程被挂起时，其状态改为 `suspend`；当协程中的方法执行到 `return` 语句时，就会转入 `dead` 状态，同时返回 return 的值。协程变为 `dead` 状态后无法再重新启动。

需要注意的是，创建协程的方法有 create 和 wrap，但是这两者是略有不同的。create 会返回一个协程，必须使用 resume 才能将其启动。而 wrap 则是返回一个函数，当调用函数时协程就会启动。