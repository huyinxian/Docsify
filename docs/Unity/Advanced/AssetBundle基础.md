# AssetBundle基础

本章将介绍 AssetBundle 的基础知识，不涉及具体的代码。实践环节我将放在框架总结的部分，并用一个游戏 Demo 来进行讲解。

## Unity中的资源加载方式

---

简单点来说，AssetBundle 其实就是一种特殊的资源压缩包，我们可以事先将游戏所需的各种资源打成 AB 包，然后在游戏运行时加载对应资源包即可。

首先来说一下 Unity 常用的资源加载方式：

```csharp
UnityEditor.AssetDatabase.LoadAssetAtPath<Material>("Assets/XXX.mat");
Resources.Load("Assets/XXX.mat");
```

第一种方式仅用于编辑器中，也就是说我们在开发游戏的过程可以采用这种方式，但在实际的游戏运行中是无法采用该方式的。第二种方式虽然在编辑器外也可以使用，但这个方式有一个很大的问题，就是所有的资源必须放到工程根目录的 Resources 文件夹下。

## Resources VS AssetBundle

---

为什么一般不推荐使用 Resources 加载呢？因为它有以下几个缺点：

* Resources 文件夹在真机环境中只有读权限，无法进行资源更新
* 不管资源有没有使用，Unity 都会把 Resources 文件夹打成一个大的包
* Resources 文件夹在真机环境中不得大于 2GB

相比较而言，AssetBundle 可以根据开发者的需求，将资源分开打包，加载时只需要加载对应的包即可，从效率上来说是要高于 Resources 加载的（因为它会把所有资源打成一个整包）。除此之外，使用 AB 包也有利于我们进行游戏的热更新，我们只需要在每次更新时比对两个版本之间的差异，然后下载差异部分的 AB 包进行覆盖即可（可以用 MD5 或者 GUID 对文件进行唯一标识）。

不过话又说回来，虽然 AssetBundle 有种种好，但并不代表 Resources 就完全被抛弃了。一般出于减少游戏安装包大小的考虑，我们可以事先把所有的 AB 包上传到服务器，只在 Resources 中放一个基本的下载界面。这样，玩家在初次运行游戏时就会自动下载剩余所需的资源，既能减少包体大小又能够完成更新。

?> 无论你想把游戏发布到哪个平台，都建议对资源进行打包。

## AssetBundle的加载与卸载

---

### 加载流程

先来看这么一个情形：比如我们需要加载一个人物，那么这个人物身上所依赖的模型、材质、Shader 等等资源都需要事先加载出来。如果我们在打包时将各个资源打到了不同的包中，那么在使用时就必须将这些包都加载一遍才行，否则就会出现资源缺失的报错提示。

这个情形就是所谓的依赖加载。当资源打包完毕后，都会生成一个与包名相同但后缀名为 `.mainfest` 的文件。该文件会记录资源包中有哪些资源、它们相对于 Assets 的路径、以及资源包所依赖的其他包。如果我们需要加载一个 AB 包，那就必须检查它有没有依赖于其它的包，有的话就先加载其它的，没有的话再加载自身，如果依赖的包同时又依赖于另外一个包，那么也是要将其加载进来的。正是这样一种类似递归的加载方式，才保证了我们加载出来的资源是完整无缺的。

AssetBundle 加载方式如下：

```csharp
// 把AB包加载到内存中
var ab = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, "myassetBundle"));
// 从AB包的内存镜像中加载音乐资源
AudioClip clip = ab.LoadAsset<AudioClip>("music");
```

### 卸载流程

说完了加载，再来说说卸载。其实卸载和加载是差不多的，当我们需要卸载一个包时，需要先查看包中的资源是否被其他对象所引用，没有引用时才能够将其卸载。

打个比方，如果我们要卸载某个游戏人物，而该人物所使用的材质、Shader 等资源没有被其他对象所使用，那么就可以将它们一起卸载。反过来，假如还有其他对象使用了和该人物一样的资源，那么这些资源就不能够被卸载。

为了准确地判断资源包是否有被引用，我们可以使用引用计数来记录资源包的引用情况。每当有对象引用资源包内的资源时，就对引用计数进行递增；每当有对象取消了对包内资源的引用时，就对引用计数进行递减。而只有当引用计数归零时，我们才可以卸载资源包，否则操作是无效的。

### 资源卸载可能导致的问题

然而，哪怕使用了引用计数，我们也依旧需要对资源卸载持谨慎的态度。首先来看一下 AssetBundle 的卸载方式：

```csharp
// 释放AB包的内存镜像，但对AB包加载出来的资源不作处理
AssetBundle.Unload(false);
// 释放AB包的内存镜像，并销毁所有从AB包中加载出来的资源对象
AssetBundle.Unload(true);
```

Unity 在实例化游戏对象时，其实是复制和引用并行的，游戏对象的销毁仅仅只会删除那些复制出来的部分（比如 Transform 等脚本实例），而引用的 材质、贴图等资源则不会被销毁。当我们采用第一种方式时，虽然 AB 包被卸载了，但加载出来的资源是不会被卸载的。如果我们没有对这些资源进行管理，那么当引用它们的游戏对象被销毁时，这些资源就成了游离的数据块，也就引发了内存泄漏。

第二种卸载方式虽然会把加载出来的资源也卸载掉，但前提是你必须保证没有对象在使用它们，否则就会导致游戏对象缺失资源。在实际的游戏运行中，我们很难判断哪些资源该卸载而哪些不该卸载，如果一定要卸载的话，最好是在切换场景时卸载上一个场景加载的 AB 包。另外，当内存达到峰值时，也可以调用 `Resources.UnloadUnusedAssets()` 来清理无引用的资源。

关于内存管理的话题就不在这里展开了，我会单独拿出来做一个总结。