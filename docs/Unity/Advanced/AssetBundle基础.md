# AssetBundle基础

本章将介绍 AssetBundle 的基础知识，不涉及具体的代码。实践环节我将放在框架总结的部分，并用一个游戏 Demo 来进行讲解。

## Unity中的资源加载方式

---

简单点来说，AssetBundle 其实就是一种特殊的资源压缩包，可以包含材质、纹理、模型、场景等资源，**但不能够包含脚本**。AssetBundle 文件可以按需加载到游戏中，并且能够被下载的包替换，是当前热更新技术必不可少的一环。

首先来说一下 Unity 常用的资源加载方式：

```csharp
UnityEditor.AssetDatabase.LoadAssetAtPath<Material>("Assets/XXX.mat");
Resources.Load("Assets/XXX.mat");
```

第一种方式仅用于编辑器中，也就是说我们在开发游戏的过程可以采用这种方式，但在实际的游戏运行中是无法采用该方式的。第二种方式虽然在编辑器外也可以使用，但这个方式有一个很大的问题，就是所有的资源必须放到工程根目录的 Resources 文件夹下。

?> WWW 类也可以用于加载，不过其主要的作用还是下载资源。

## Resources VS AssetBundle

---

其实从本质上来说，Resources 内的文件会在游戏发布时打进一个 AssetBundle，所以这两种方式是差不多的。不过呢，我依旧不推荐使用 Resources 加载，原因如下：

* Resources 文件夹在真机环境中只有读权限，无法进行资源更新
* 不管资源有没有使用，Unity 都会把 Resources 文件夹打成一个大的包
* Resources 文件夹在真机环境中不得大于 2GB

相比较而言，AssetBundle 可以根据开发者的需求，将资源分开打包，加载时只需要加载对应的包即可，从效率上来说是要高于 Resources 加载的。除此之外，使用 AB 包也有利于我们进行游戏的热更新，我们只需要在每次更新时比对两个版本之间的差异，然后下载差异部分的 AB 包进行覆盖即可（可以用 MD5 或者 GUID 对文件进行唯一标识）。

不过话又说回来，虽然 AssetBundle 有种种好，但并不代表 Resources 就完全被抛弃了。一般出于减少游戏安装包大小的考虑，我们可以事先把所有的 AB 包上传到服务器，只在 Resources 中放一个基本的下载界面。这样，玩家在初次运行游戏时就会自动下载剩余所需的资源，既能减少包体大小又能够完成更新。

?> 无论你想把游戏发布到哪个平台，都建议对资源进行打包。

## AssetBundle的加载与卸载

---

### 加载流程

先来看这么一个情形：比如我们需要加载一个人物，那么这个人物身上所依赖的材质、纹理、Shader 等等资源都需要事先加载出来。也就是说，如果游戏采用的是 AssetBundle 进行加载，那么你就得先加载材质包，然后才能够加载人物模型。

这个情形就是所谓的**依赖加载**。当资源打包完毕后，都会生成一个与包名相同但后缀名为 `.manifest` 的文件。该文件会记录资源包中有哪些资源、它们相对于 Assets 的路径、以及资源包所依赖的其他包。如果我们需要加载一个 AB 包，那就必须检查它有没有依赖于其它的包，有的话就先加载其它的，没有的话再加载自身，如果依赖的包同时又依赖于另外一个包，那么也是要将其加载进来的。正是这样一种类似递归的加载方式，才保证了我们加载出来的资源是完整无缺的。

AssetBundle 加载方式如下：

```csharp
// 把AB包加载到内存中
var ab = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, "myassetBundle"));
// 从AB包的内存镜像中加载音乐资源
AudioClip clip = ab.LoadAsset<AudioClip>("music");
```

### 卸载流程

说完了加载，再来说说卸载。其实卸载和加载是差不多的，当我们需要卸载一个包时，需要先查看包中的资源是否被其他对象所引用，没有引用时才能够将其卸载。

打个比方，如果我们要卸载某个游戏人物，而该人物所使用的材质、Shader 等资源没有被其他对象所使用，那么就可以将它们一起卸载。反过来，假如还有其他对象使用了和该人物一样的资源，那么这些资源就不能够被卸载。

为了准确地判断资源包是否有被引用，我们可以使用引用计数来记录资源包的引用情况。每当有对象引用资源包内的资源时，就对引用计数进行递增；每当有对象取消了对包内资源的引用时，就对引用计数进行递减。而只有当引用计数归零时，我们才可以卸载资源包，否则操作是无效的。

### 资源卸载可能导致的问题

然而，哪怕使用了引用计数，我们也依旧需要对资源卸载持谨慎的态度。首先来看一下 AssetBundle 的卸载方式：

```csharp
// 释放AB包的内存镜像，但对AB包加载出来的资源不作处理
AssetBundle.Unload(false);
// 释放AB包的内存镜像，并销毁所有从AB包中加载出来的资源对象
AssetBundle.Unload(true);
```

Unity 在实例化游戏对象时，其实是复制和引用并行的，游戏对象的销毁仅仅只会删除那些复制出来的部分（比如 Transform 等脚本实例），而引用的 材质、贴图等资源则不会被销毁。当我们采用第一种方式时，虽然 AB 包被卸载了，但加载出来的资源是不会被卸载的。如果我们没有对这些资源进行管理，那么当引用它们的游戏对象被销毁时，这些资源就成了游离的数据块，也就引发了内存泄漏。

第二种卸载方式虽然会把加载出来的资源也卸载掉，但前提是你必须保证没有对象在使用它们，否则就会导致游戏对象缺失资源。在实际的游戏运行中，我们很难判断哪些资源该卸载而哪些不该卸载，如果一定要卸载的话，最好是在切换场景时卸载上一个场景加载的 AB 包。另外，当内存达到峰值时，也可以调用 `Resources.UnloadUnusedAssets()` 来清理无引用的资源。

关于内存管理的话题就不在这里展开了，我会单独拿出来做一个总结。

## 如何选择打包内容

---

在开始打包前，我们需要对包体的大小和数量进行一个平衡。假如把所有的资源都打一个包，那么我们在加载资源时就会加进来许多用不到的资源，白白浪费内存，而且只打一个包也很不利于热更新。如果是打成多个包，那么就有可能造成冗余，导致多个包中包含同一个资源，同时也容易造成依赖关系混乱。

每个游戏都有每个游戏的玩法，所以打包的方式也得根据项目本身来决定。你既可以根据资源的类别进行打包（比如怪物、人物、道具），也可以根据场景的不同进行打包（比如不同场景的 UI 可以分开打包），但具体怎么来做还是看各自的需求。

## 处理AssetBundle冗余

---

什么是 AssetBundle 冗余呢？简单点来说，就是多个包中包含了同一个资源，导致包体变大的情形。虽然在 5.x 版本之后，Unity 提供了自动化依赖打包，对于指定的资源，Unity 会自动收集其依赖的资源并打进同一个包中。如果依赖的资源已经存在于其他包中，那么两个包之间就会形成依赖关系。

不过上面所述的只是理想的情况，假如有两个 AB 包同时依赖于一个没有被打包的资源，那么该资源就会被分别打进两个包，造成了资源冗余。为了避免这一情形，我们需要在打包前对所有资源进行过滤，保证 AB 包中不会出现重复的资源。具体的代码我会在资源加载框架中进行讲解。

## 其他需要注意的问题

---

### 不同平台用不同的包

我们在打包时用的是如下代码：

```csharp
BuildPipeline.BuildAssetBundles(ABOutputPath, BuildAssetBundleOptions.ChunkBasedCompression,
            EditorUserBuildSettings.activeBuildTarget);
```

第三个参数代表的是游戏想要发布的平台，也就是 AssetBundle 在生成时是区分不同平台的。如果我们的游戏需要分别发布到安卓和 IOS 平台，那么就需要分别对这两个平台进行打包，并且两个平台的 AB 包不能够混用。

### 打包的时候不能包含脚本

AssetBundle 中是不能包含脚本的，虽然它可以作为文本资源（TextAsset）的形式存在，但是这样一来就不能够执行代码了。如果我们想在包中加入脚本，并且希望脚本在程序中执行，那么脚本就需要被编译为程序集，然后用反射来加载脚本（使用 AOT 进行编译的平台不行，例如 IOS）。

如果你想要做到真正的热更新，那么还是建议使用类似于 Lua 的解释型语言进行开发。

### 不要随意删除manifest

哪怕你在打包的时候自己生成了一个 AssetBundle 配置表，也请不要把 Unity 自动生成的 `manifest` 文件删掉，否则你每次都会从头开始打包。`manifest` 除了记录资源路径、依赖、crc 等信息外，更重要的一个作用是增量打包（可以自行对比一下删除 manifest 和不删除的打包速度）。