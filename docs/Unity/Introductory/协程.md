# 协程

协程是 C# 的强大功能。在 Unity 中，协程的功能就如同开启了一个线程，可以执行相应的操作。不过，如果你看过 Unity 的生命周期，你就会明白 Unity 其实是单线程的，协程并没有实际上创建线程，只是效果上类似而已。

!> 协程并不会开辟新的线程，请牢记这一点。

## 为什么要使用协程

---

先来看一个场景，例如你想要让物体逐渐变透明，那么你可能会这么写：

```csharp
void FadeColor() {
    for (float f = 1f; f >= 0f; f -= 0.1f) {
        Color tempColor = renderer.material.color;
        tempColor.a = f;
        renderer.material.color = tempColor;
    }
}
```

不过这样写是不行的，由于这个方法会在一帧内执行完毕，所以你只会看到物体突然一下就消失了。显然，我们得使用 `Update()` 逐渐地改变物体的透明度：

```csharp
float timer = 0;
float fadeTime = 1f;

void Update() {
    timer += Time.deltaTime;
    Color tempColor = renderer.material.color;
    tempColor.a = 1f - timer / fadeTime;
    renderer.material.color = tempColor;
}
```

这样写是可以的，不过当你写了很多个方法之后，你的代码会显得很杂乱。那么，有没有一种既达到要求又比较优雅的写法呢？

## 开启协程

---

协程可以根据你的需要，在某个时刻停下来，然后在下一帧中执行后续的代码。举个例子：

```csharp
int sum = 0;

IEnumerator Calc() {
    for (int i = 0; i < 10000; i++) {
        // 累加
        sum += i;

        // 每帧执行一次
        yield return null;
    }
}
```

当循环执行到 `yield return null` 时就会停住，然后等到下一帧时才会继续执行代码。

!> 不要将 `yield return null` 写到循环外面，那样的话跟直接写一个循环没有任何区别。

如果你想要开启协程，方法很简单：

```csharp
// 第一种写法
StartCoroutine(Calc());
StartCoroutine(Calc(1));    // 向方法中传递参数

// 第二种写法
StartCoroutine("Calc");
StartCoroutine("Calc", 1);  // 向方法中传递参数
```

在你需要的调用这个方法，比如初始化的时候，协程就会启动，然后执行一系列代码。

!> 两种写法只能选一个，你必须保证开启协程和停止协程用的是同一种写法。

## 停止协程

---

停止协程用的是下面的方法：

```csharp
// 第一种
StopCoroutine(Calc());

// 第二种
StopCoroutine("Calc");
```

如果你想要停止多个协程，可以使用 `StopCoroutines()`，该方法会停止当前 MonoBehaviour 类实例中的所有协程。如果想要停止当前游戏对象上的所有协程，你需要禁用游戏对象：

```csharp
gameobject.SetActive(false);
```

最后再重申一遍，开启协程和停止协程必须要用同一种写法。

## yield return

---

协程中最主要的就是 `yield` 的调用时机，对于复杂的运算，会有不同的 `yield` 调用方式。

### 不使用关键字new

可以返回的值有很多种，比如 null、数值、字符串、布尔值、表达式，甚至可以是函数和嵌套调用协程。只要不使用关键字 `new`，那么等待的时间都是一帧。至于它们具体执行的时间，则是在 `Update()` 与 `LateUpdate()` 之间。

另外需要注意的是，如果返回的是函数、赋值表达式、协程等，那么它们将会被立即调用。

?> 关于 `yield return null` 等协程的执行时间，官方给出的图解是在 `Update()` 和 `LateUpdate()` 之间执行，不过也有人说是在 `LateUpdate()` 之后执行。至于具体结果如何还是需要进一步研究。

### 使用关键字new

比如 `new WaitForSeconds(float)`，这个是最常用的功能之一，参数为等待的时间。至于其他的，还是请看下面的示例。

### 示例

```csharp
yield return null;                              // 不管返回的值是多少，效果都是下一帧再继续执行代码
yield break;                                    // 直接结束协程
yield return asyncOperation;                    // 等待异步操作后再继续执行
yield return StartCoroutine(Calc());            // 等待某个协程执行完毕后再执行代码
yield return WWW();                             // 等待WWW执行完毕后再执行代码
yield return new WaitForEndOfFrame();           // 等待帧结束，在该帧显示在屏幕之前执行
yield return new WaitForSeconds(0.3f);          // 等待0.3秒，受到Time.timeScale的影响
yield return new WaitForSecondsRealtime(0.3f);  // 等待0.3秒，不受到Time.timeScale的影响
yield return WaitForFixedUpdate();              // 等待下一次FixedUpdate开始时再执行后续代码
yield return new WaitUntil();                   // 当输入的参数（或者委托）为true的时等待，如:yield return new WaitUntil(() => frame >= 10);
yield return new WaitWhile();                   // 当输入的参数（或者委托）为false的时候等待，如:yield return new WaitWhile(() => frame < 10);
```

### 协程的执行顺序

---

来看看下面这一段代码：

```csharp
void Start() {
    Debug.Log("start1");
    StartCoroutine(Test());
    Debug.Log("start2");
}

IEnumerator Test() {
    Debug.Log("test1");
    yield return null;
    Debug.Log("test2");
}
```

运行结果如下：

    start1
    test1
    start2
    test2

从结果来看，当 `StartCoroutine()` 被调用时，就相当于调用了 `Test()` 方法，然后执行到 `yield return null` 时等待。接下来返回到 `Start()` 方法中继续执行代码，然后下一帧再执行 `Test()` 的后续代码。

如果你把代码改成 `yield return new WaitForSeconds(3)`，那么 test2 将等待 3 秒后才会打印。这一结果说明了一点，那就是 `yield return` 的值决定了协程什么时候继续执行。

那么，假如不是直接启用协程，而是在 `yield return` 中嵌套调用呢？

```csharp
void Start () {
    Debug.Log("start1");
    StartCoroutine(Test());
    Debug.Log("start2");
}

IEnumerator Test()
{
    Debug.Log("test1");
    yield return StartCoroutine(DoSomething());
    Debug.Log("test2");
}

IEnumerator DoSomething()
{
    Debug.Log("load 1");
    yield return null;
    Debug.Log("load 2");
}
```

结果如下：

    start1
    test1
    load1
    start2
    load2
    test2

这一下区别就出来，如果是直接使用 `StartCoroutine()`，那么当调用的协程等待时将会立即返回。但如果是嵌套调用协程，那么就必须等待这个协程全部执行完毕后才会返回。

## 协程与线程的区别

---

其实二者并没有任何关系，因为 Unity 是单线程的，协程只是看起来像线程，但它其实是在生命周期的多个位置处调用，本质上还是单线程。

## 协程的原理

---

了解过生命周期你就会明白，协程与 `Update()` 其实没什么区别，都会在每一帧去处理相应的操作。协程的本质是迭代器，会执行到某个节点时进行记录，等到下一次时接着执行。