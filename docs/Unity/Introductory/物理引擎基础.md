# 物理引擎基础

Unity 的物理引擎使用的是 Nvida 的 PhysX 引擎。Unity 有两种物理引擎，分别是 3D 和 2D，它们没有太大的区别，只是组件有些不同罢了。

## 刚体

---

刚体可以为游戏物体添加物理属性，例如重力等因素。由于刚体可以控制物体的移动，所以当游戏对象添加了刚体之后，就不要再用 Transform 组件来移动了，可以用类似于 `Addforce`、`velocity`、`MovePosition` 等方法。

不过有的时候，游戏对象需要刚体组件，但又不需要受到物理作用，比如物体仅仅需要触发碰撞事件，这时候就可以将刚体设置为 `Kinematic`（运动学）。如果启用了这个设置，物体将不再受力的作用，且只能够通过 Transform 来操作。不过一般来说，不要在游戏运行中切换该属性，那样比较影响游戏效率。

!> Transform 的移动相当于直接改变物体的位置（瞬移），对于碰撞检测等物理行为会有影响。因此，为物体添加刚体后，请使用刚体的方式来进行移动。

## 碰撞器

---

碰撞器定义了游戏对象在碰撞时的形状，是不可见的，在场景视图中用绿色线框标识。原始的碰撞器是最简单也是效率最高的，共有 `Box Collider`（盒子碰撞器）、`Sphere Collider`（球体碰撞器）、`Capsule Collider`（胶囊碰撞器）三种。你可以为游戏物体添加多种碰撞器，这种组合起来的碰撞器可以近似地模拟复杂的网格模型。子游戏对象可以有碰撞器，但是不能够再有刚体。

当然，你也可以添加与模型完全一样的碰撞器，这种碰撞器名为 `Mesh Collider`（网格碰撞器）。需要注意的是，这种碰撞器虽然非常精细，但是它占据的性能也很多，所以得小心使用。一般来说，非原始碰撞器之间是不会发生碰撞的，比如两个网格碰撞器就不会碰撞。只有标记为 `Convex`（凸起）的网格碰撞器才可以发生碰撞。

?> 一般来说，场景是使用网格碰撞器，而角色等移动的物体使用原始碰撞器。当然，碰撞器也可以不加刚体单独使用，比如场景这种静态物体。

## 物理材质

---

物理材质（Physics Material）用于模拟物体的表面属性，比如冰球和橡胶球的碰撞效果肯定是不一样的。下面来制作一个简单的弹球。

新建一个球体，为它添加刚体，然后创建一个地面。这时如果运行游戏，球体会落到地面上，但是并不会弹起。为了达成这个效果，我们需要为它添加物理材质。

新建一个物理材质，将材质的 `Bounciness` 属性设置为 1，然后为球体添加该材质。

再运行游戏，球体就会不断地弹起，最终停住。

## 触发器

---

触发器用来触发事件。比如玩家靠近一扇门，门会自动打开，又或者是走到一个位置后会触发某个事件。碰撞器有一个属性 `Is Trigger`，将其勾选上后，碰撞器就成为了触发器，同时也不再受到物理行为的作用。

## 射线

---

射线是 3D 游戏中常用的一种技术，例如寻路、AI逻辑、判定命中。当敌人在巡逻时，如果玩家处在敌人的视野中，就会自动发起攻击。

新建一个球体和一个立方体，然后让球体朝着立方体移动：

```csharp
private Vector3 direction = new Vector3(1, 0, 0);
private float distace = 1f;

void Update() {
    GetComponent<RigidBody>().velocity = direction;

    // 创建一个射线
    Ray ray = new Ray(transform.position, direction);

    // RaycastHit是用于记录射线碰撞信息的类
    RaycastHit info;

    // 发射射线
    if (Physics.Raycast(ray, out info, instance)) {
        // 发现障碍
        Debug.Log("发现障碍" + info.collider.name);
    }

    // 用DrawLine显示射线
    Debug.DrawLine(ray.origin, ray.origin + direction * distance);
}
```

当射线检测到障碍物时，就会打印出一条信息。

?> `Physics.Raycast()` 有多种参数形式，可以自己去了解一下。

## 如何检测高速运动物体

---

Unity 中的碰撞检测其实存在一个问题。由于检测逻辑是每帧进行的，当物体的运动速度过快时，可能还来不及检测就让物体穿过去了。为了避免这一情况，我们可以设置刚体中的 `Collision Detection` 参数，该参数有三个选项：

* Discrete：离散检测，用于正常碰撞。
* Continuous：连续检测，当碰撞体遇到其他的动态碰撞体（包含刚体组件）时使用离散检测，遇到静态碰撞体（即不含刚体）时使用连续检测。如果是其他设置为连续检测的碰撞体遇到该物体，那么就会使用连续检测，否则使用离散检测。该选项用于高速运动物体。
* Continuous Dynamic：连续动态，当碰撞体遇到其他设置为动态或者连续动态的物体时使用连续检测，在遇到静态物体时也使用连续检测。遇到设置为离散的物体则使用离散检测。该选项用于高速运动物体。

上面说的可能有点绕，我们可以看下表格：

| 碰撞体/被碰撞体 | 静态 | 离散 | 连续 | 动态连续 |
| :--- | :--- | :--- | :--- | :--- |
| 离散 | 离散 | 离散 | 离散 | 离散 |
| 连续 | 连续 | 离散 | 离散 | 离散 |
| 连续动态 | 连续 | 离散 | 连续 | 连续 |

如果你有一个高速运动的物体会穿过一面静止的墙，那么你可以把小球设置为动态。当你有多个高速运动的小球，且小球之间会相互穿透时，你可以把这些小球设置为连续动态。不过要注意，当这样的物体过多时会消耗机器的性能。

一般来说，把物体设置为动态或者连续动态就可以解决高速运动的问题，但是在某些情况下仍然会导致相同的 BUG，这时候我们就必须做射线检测。思路的话其实不难，只要让小球向运动方向发射一定距离的射线，如果检测到物体就算做碰撞。