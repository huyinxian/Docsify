# UGUI基础

其实我原本并不打算写 UGUI 的基础笔记，但之后转念一想，我写了 NGUI 的基础笔记总不能冷落了 UGUI 吧？嗯，也就当作是梳理一下基础知识好了。

## UGUI与NGUI

---

就我个人的感受来说，UGUI 的操作性要比 NGUI 好一些。但 NGUI 毕竟做了这么多年，功能与控件要比 UGUI 齐全很多，所以其孰好孰坏的话题也一直在争论中。对于这个问题，最好的解决方法是两个都有了解，然后根据实际需要自行选择。毕竟，每个公司的工作方法都不太一样，掌握得多点总是好的。

## 图片资源

---

精灵（Sprite）就是 UI 的基本元素。我们在导入 UI 资源的时候，要记得把图片的类型设置为 `Sprite(2D and UI)`。另外，如果你的工程是 2D 的，那么导入的图片就会自动设置为精灵。

精灵的属性面板如下所示。注意，如果你对设置做出了更改，那么记得点击最下面的 `Apply` 按钮进行提交。

![](http://obkyr9y96.bkt.clouddn.com/image/post/U3D/UGUI%E5%9F%BA%E7%A1%80/01.png)

简要的介绍一下基础属性，其它不常用的我就暂时不介绍了。

* **Sprite Mode**：精灵模式。如果该图片是一张图集，那么你可以把模式设置为 `Multiple`（多图）。
* **Packing Tag**：打包标签。相同标签的精灵在打包时会被分为一组。
* **Pixels To Units**：像素/单位。Unity 以米为单位，所以这里表示多少个像素换算成一米。
* **Pivot**：中心点。当你选中矩形工具时，精灵中间的蓝色圆圈就是中心点。

当你需要对精灵切图时，记得先把模式调成 `Multiple`，然后在 `Sprite Editor` 中对图片进行裁切。裁切出来的小图片会出现在图集中，你可以额外为其设置新的名称。

关于切图的问题，我在其他的游戏案例中已经讲过很多了，这里就不再多说了。唯一需要注意的是，蓝色的矩形框负责裁切精灵，而绿色的矩形框则是用于精灵的九宫格切图，记得不要搞混了。

![](http://obkyr9y96.bkt.clouddn.com/image/post/U3D/MVC%E5%BC%80%E5%8F%91%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/06.png)

## Canvas

---

Canvas 画布就类似于 NGUI 中的 UIRoot，都是 UI 树的根节点。画布身上有三个组件，分别是 `Canvas`、`Canvas Scaler`、`Graphic Raycaster`。我们一个个地看。

### Canvas组件

作为与画布同名的组件，主要的功能是设置 UI 的渲染模式。

首先是 `Screen Space-Overlay`。在该模式下，画布会自动填满整个屏幕空间，并且画布是永远处于屏幕最上方的。如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕。

![](http://obkyr9y96.bkt.clouddn.com/image/post/U3D/UGUI%E5%9F%BA%E7%A1%80/02.png)

* **Pixel Perfect**：勾选该选项将让像素一直保持清晰，最明显的效果就是不管屏幕分辨率如何变化，精灵的边缘都不会模糊。
* **Sort Order**：用于指定画布的深度。

其次就是 `Screen Space-Camera`。该模式与上一个类似，画布也会自动布满整个屏幕。不同的是，该模式的画布会被放置在某个摄像机前，所以需要你手动制定一个相机。在该模式下，画布会看起来绘制在一个与摄像机固定距离的平面上，所有 UI 元素都由该摄像机渲染，因此摄像机的设置会影响 UI 画面（比如相机的视角）。

![](http://obkyr9y96.bkt.clouddn.com/image/post/U3D/UGUI%E5%9F%BA%E7%A1%80/03.png)

* **Render Camera**：用于渲染的相机。
* **Plane Distance**：画布平面与相机的距离。

此外还有 `World Space`。在该模式下，画布将会被视作与场景中的游戏对象一样，类似于一张平面的物体。此时你可以调整画布的 `RectTransform`，设置画布的位置和大小。比如在坦克大战的案例中，我就把画布设置成了一个平面对象，并将它嵌套在坦克上用以充当血条。

它有一个独有的参数 `Event Camera`，主要用来指定接收事件的相机，可以通过画布上的 `GraphicRaycaster` 组件发射射线产生事件。

### CanvasScaler组件

该组件的主要作用是负责屏幕的适配，一共有三种方式。

首先是 `Constant Pixel Size`。该模式会调节画布像素大小从而维持缩放不变。简单点说，只有画布的大小会改变，而 UI 的缩放倍数（Scale Factor）默认是不会改变的。然而，这种做法虽然可以保持图片原本的分辨率，但是当游戏窗口过大或者过小时，你还是得通过脚本来修改缩放倍数，避免 UI 在小窗口中太大、在大窗口中小到看不清。

其次是 `Scale With Screen Size`。这种模式比较方便，你需要指定一个设计分辨率和缩放算法。当实际宽高比和设计宽高比相同时，UI 会等比例缩放。只有二者不同时，缩放算法才会起作用。缩放算法一共有三种：扩展、收缩、匹配宽高。扩展是把画布较短的一边扩大，使得实际宽高比等于设计宽高比；收缩则是相反，画布较长的一边会缩短，使得实际宽高比等于设计宽高比；匹配宽高是根据指定好的权重，同时调节画布的宽高，尽可能保持 UI 原本的模样。

最后是 `Constant Physical Size`。这种模式和第一种类似，只不过该模式是调节画布的物理大小从而维持缩放不变。使用该模式时得制定一个像素转换物理大小的因数（一般写96），运行时会根据具体设备的 DPI 来计算画布的大小以及缩放系数。这种方式旨在使用物理单位而非像素单位，但就目前的情况而言，开发以及美术人员显然更关心图片的像素大小。

它们的对比如下：

| 模式 | 功能 |
| :--- | :--- |
| Constant Pixel Size | UI元素始终保持原来的像素大小 |
| Scale With Screen Size | UI的大小随着屏幕的改变而改变 |
| Constant Physical Size | UI元素始终保持原来的物理尺寸 |

### GraphicRaycaster组件

上面有提及过，该组件主要用来发射射线产生事件。

## EventSystem

---

在创建画布时，Unity 会自动创建一个 `EventSystem`。该对象主要用来监听用户的输入，如果需要屏蔽的话直接将该对象设置为未激活即可。`UnityEngine.EventSystems.EventSystem.current` 用于保存当前活动的 `EventSystem` 对象，可以根据需要调用。

## Image

---

Image 是 UGUI 中用于显示图片的控件，所有的 UI 元素都是以矩形来表现的，因此 UGUI 的控件都会带有 `RectTransform` 组件。如果你想要显示一个精灵图片，还请使用 Image 控件。

Image 组件中有一个 `Sprite` 属性，这个属性指向我们需要显示的图片。另外，由于 UI 是 2D 的，所以你需要把图片的贴图格式（Texture Type）修改成 `Sprite (2D and UI)`。

![](http://obkyr9y96.bkt.clouddn.com/image/post/U3D/UGUI%E5%9F%BA%E7%A1%80/04.png)

`RectTransform` 中的 `Anchor` 属性是用来设置锚点的，效果类似于 NGUI 中的 `Anchor` 属性，但是要方便很多。`Anchor` 中有一个 `stretch` 属性，它主要是用来设置 UI 的拉伸方式，当然你也可以直接拖动锚点的四个小三角：

![](http://obkyr9y96.bkt.clouddn.com/image/post/U3D/UGUI%E5%9F%BA%E7%A1%80/05.png)

在上图中，背景被设置为了四角拉伸，这样背景的尺寸就会保持和父对象一致。

另外，当你按住 `Alt` 键时，点击你想要的锚点位置可以直接把 UI 移动到该位置。比如背景图一开始很小，你想要让背景图和画布一样大，就可以按住 `Alt` 后再点击四角拉伸。位置改变也是同理。

属性描述如下：

* **Blueprint Mode**：选中该选项后，移动工具将不受元素的旋转和缩放影响。比如我们在旋转 3D 物体时，经常会出现移动工具跟着物体进行旋转的情况，这时你改变坐标系就不会受到影响了。道理是一样的。
* **Raw Edit Mode**：对 Pivot 进行操作不会影响元素的位置信息。
* **Raycast Target**：是否让 UI 元素接收射线。
* **Preserve Aspect**：是否保留精灵的原图形，不进行自动剔除。

`RayCast Target` 我在俄罗斯方块案例中讲过，主要的作用是隔绝某个 UI 下的元素。其实这种说法不对，UGUI 在接收到事件时（比如点击事件），会遍历所有接收射线的 UI，然后在点击的位置发射一条射线，找到最先接收到射线的 UI，并抛出这个事件。

对于不需要进行交互的元素，我们最好取消这个选项，因为它有可能会处在某个按钮的上面，这样就会把按钮给屏蔽掉。当然，你也可以利用这个特性来做一个遮罩，屏蔽掉玩家的操作（比如暂停界面不允许玩家乱摁按钮）。